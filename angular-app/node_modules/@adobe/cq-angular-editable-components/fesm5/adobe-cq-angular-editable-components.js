import { ComponentMapping } from '@adobe/cq-spa-component-mapping';
import { Constants, ModelManager } from '@adobe/cq-spa-page-model-manager';
import { Directive, Input, Renderer2, NgZone, ViewContainerRef, ComponentFactoryResolver, Component, NgModule, Injectable } from '@angular/core';
import { __extends } from 'tslib';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The current class extends the \@adobe/cq-spa-component-mapping#Mapto library and features with Angular specifics such as
 *
 * - Storing the editing configurations for each resource type
 */
var  /**
 * The current class extends the \@adobe/cq-spa-component-mapping#Mapto library and features with Angular specifics such as
 *
 * - Storing the editing configurations for each resource type
 */
ComponentMappingWithConfig = /** @class */ (function () {
    function ComponentMappingWithConfig(spaMapping) {
        this.spaMapping = spaMapping;
        /**
         * Store of EditConfig structures
         */
        this.editConfigMap = {};
    }
    /**
     * Stores a component class for the given resource types and also allows to provide an EditConfig object
     * @param resourceTypes - List of resource types
     * @param clazz - Component class to be stored
     * @param [editConfig] - Edit configuration to be stored for the given resource types
     */
    /**
     * Stores a component class for the given resource types and also allows to provide an EditConfig object
     * @param {?} resourceTypes - List of resource types
     * @param {?} clazz - Component class to be stored
     * @param {?=} editConfig
     * @return {?}
     */
    ComponentMappingWithConfig.prototype.map = /**
     * Stores a component class for the given resource types and also allows to provide an EditConfig object
     * @param {?} resourceTypes - List of resource types
     * @param {?} clazz - Component class to be stored
     * @param {?=} editConfig
     * @return {?}
     */
    function (resourceTypes, clazz, editConfig) {
        if (editConfig === void 0) { editConfig = null; }
        var /** @type {?} */ innerClass = clazz;
        if (editConfig) {
            this.editConfigMap[resourceTypes] = editConfig;
        }
        this.spaMapping.map(resourceTypes, innerClass);
    };
    /**
     * Returns the component class for the given resourceType
     * @param resourceType - Resource type for which the component class has been stored
     */
    /**
     * Returns the component class for the given resourceType
     * @param {?} resourceType - Resource type for which the component class has been stored
     * @return {?}
     */
    ComponentMappingWithConfig.prototype.get = /**
     * Returns the component class for the given resourceType
     * @param {?} resourceType - Resource type for which the component class has been stored
     * @return {?}
     */
    function (resourceType) {
        return this.spaMapping.get(resourceType);
    };
    /**
     * Returns the EditConfig structure for the given type
     * @param resourceType - Resource type for which the configuration has been stored
     */
    /**
     * Returns the EditConfig structure for the given type
     * @param {?} resourceType - Resource type for which the configuration has been stored
     * @return {?}
     */
    ComponentMappingWithConfig.prototype.getEditConfig = /**
     * Returns the EditConfig structure for the given type
     * @param {?} resourceType - Resource type for which the configuration has been stored
     * @return {?}
     */
    function (resourceType) {
        return this.editConfigMap[resourceType];
    };
    return ComponentMappingWithConfig;
}());
var /** @type {?} */ componentMapping = new ComponentMappingWithConfig(ComponentMapping);
/**
 * @param {?} resourceTypes
 * @return {?}
 */
function MapTo(resourceTypes) {
    return function (clazz, editConfig) {
        if (editConfig === void 0) { editConfig = null; }
        return componentMapping.map(resourceTypes, clazz, editConfig);
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ Constants$1 = {
    /**
         * Class names associated with a new section component
         *
         */
    NEW_SECTION_CLASS_NAMES: 'new section',
    TYPE_PROP: Constants.TYPE_PROP,
    /**
         * List of child items of an item
         *
         */
    ITEMS_PROP: Constants.ITEMS_PROP,
    /**
         * Order in which the items should be listed
         *
         */
    ITEMS_ORDER_PROP: Constants.ITEMS_ORDER_PROP,
    /**
         * Path of the item
         *
         */
    PATH_PROP: Constants.PATH_PROP,
    /**
         * Children of an item
         *
         */
    CHILDREN_PROP: Constants.CHILDREN_PROP,
    /**
         * Path of the resource in the model
         *
         */
    DATA_PATH_PROP: ':dataPath',
    /**
         * Hierarchical type of the item
         */
    HIERARCHY_TYPE_PROP: Constants.HIERARCHY_TYPE_PROP
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2018 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/**
 * Selector that identifies the node that contains the WCM mode state
 */
var /** @type {?} */ WCM_MODE_META_SELECTOR = 'meta[property="cq:wcmmode"]';
/**
 * The editor is in one of the edition modes
 */
var /** @type {?} */ EDIT_MODE = 'edit';
/**
 * The editor is in preview mode
 */
var /** @type {?} */ PREVIEW_MODE = 'preview';
/**
 * Returns if we are in the browser context or not by checking for the
 * existence of the window object
 * @return {?}
 */
function isBrowser() {
    try {
        return typeof window !== 'undefined';
    }
    catch (/** @type {?} */ e) {
        return false;
    }
}
/**
 * Returns the current WCM mode
 *
 * <p>Note that the value isn't, as of the date of this writing, updated by the editor</p>
 * @return {?}
 */
function getWCMMode() {
    if (isBrowser()) {
        var /** @type {?} */ wcmModeMeta = document.head.querySelector(WCM_MODE_META_SELECTOR);
        return wcmModeMeta && wcmModeMeta.content;
    }
}
/**
 * Helper functions for interacting with the AEM environment
 */
var /** @type {?} */ Utils = {
    /**
     * Is the app used in the context of the AEM Page editor
     */
    isInEditor: /**
     * Is the app used in the context of the AEM Page editor
     * @return {?}
     */
    function () {
        var /** @type {?} */ wcmMode = getWCMMode();
        return wcmMode && (EDIT_MODE === wcmMode || PREVIEW_MODE === wcmMode);
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ PLACEHOLDER_CLASS_NAME = 'cq-placeholder';
var AEMComponentDirective = /** @class */ (function () {
    function AEMComponentDirective(renderer, viewContainer, factoryResolver, ngZone) {
        this.renderer = renderer;
        this.viewContainer = viewContainer;
        this.factoryResolver = factoryResolver;
        this.ngZone = ngZone;
    }
    Object.defineProperty(AEMComponentDirective.prototype, "cqItem", {
        get: /**
         * @return {?}
         */
        function () {
            return this._cqItem;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._cqItem = value;
            this.updateComponentData();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AEMComponentDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.renderComponent(componentMapping.get(this.type));
    };
    Object.defineProperty(AEMComponentDirective.prototype, "type", {
        /**
         * Returns the type of the cqItem if exists.
         */
        get: /**
         * Returns the type of the cqItem if exists.
         * @return {?}
         */
        function () {
            return this.cqItem && this.cqItem[Constants$1.TYPE_PROP];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Renders a component dynamically based on the component definition
     *
     * @param {?} componentDefinition The component definition to render
     * @return {?}
     */
    AEMComponentDirective.prototype.renderComponent = /**
     * Renders a component dynamically based on the component definition
     *
     * @param {?} componentDefinition The component definition to render
     * @return {?}
     */
    function (componentDefinition) {
        if (componentDefinition) {
            var /** @type {?} */ factory = this.factoryResolver.resolveComponentFactory(componentDefinition);
            this.viewContainer.clear();
            this._component = this.viewContainer.createComponent(factory);
            this.updateComponentData();
        }
    };
    /**
     * Updates the data of the component based the data of the directive
     * @return {?}
     */
    AEMComponentDirective.prototype.updateComponentData = /**
     * Updates the data of the component based the data of the directive
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._component || !this._component.instance) {
            return;
        }
        var /** @type {?} */ keys = Object.getOwnPropertyNames(this.cqItem);
        keys.forEach(function (key) {
            var /** @type {?} */ propKey = key;
            if (propKey.startsWith(":")) {
                // Transformation of internal properties namespaced with [:] to [cq]
                // :myProperty => cqMyProperty
                var /** @type {?} */ tempKey = propKey.substr(1);
                propKey = "cq" + tempKey.substr(0, 1).toUpperCase() + tempKey.substr(1);
            }
            _this._component.instance[propKey] = _this.cqItem[key];
        });
        this._component.instance.cqPath = this.cqPath;
        this._component.instance.itemName = this.itemName;
        var /** @type {?} */ editConfig = componentMapping.getEditConfig(this.type);
        if (editConfig && Utils.isInEditor) {
            this.setupPlaceholder(editConfig);
        }
    };
    /**
     * Adds the specified item attributes to the element
     * @return {?}
     */
    AEMComponentDirective.prototype.setupItemAttrs = /**
     * Adds the specified item attributes to the element
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.itemAttrs) {
            var /** @type {?} */ keys = Object.getOwnPropertyNames(this.itemAttrs);
            keys.forEach(function (key) {
                if (key === "class") {
                    var /** @type {?} */ classes = _this.itemAttrs[key].split(' ');
                    classes.forEach(function (itemClass) {
                        _this.renderer.addClass(_this._component.location.nativeElement, itemClass);
                    });
                }
                else {
                    _this.renderer.setAttribute(_this._component.location.nativeElement, key, _this.itemAttrs[key]);
                }
            });
        }
    };
    /**
     * Determines if the placeholder should e displayed.
     *
     * @param {?} editConfig - the edit config of the directive
     * @return {?}
     */
    AEMComponentDirective.prototype.usePlaceholder = /**
     * Determines if the placeholder should e displayed.
     *
     * @param {?} editConfig - the edit config of the directive
     * @return {?}
     */
    function (editConfig) {
        return editConfig.isEmpty && typeof editConfig.isEmpty === "function" && editConfig.isEmpty(this.cqItem);
    };
    /**
     * Setups the placeholder of needed for the AEM editor
     *
     * @param {?} editConfig - the editConfig, which will dictate the classes to be added on.
     * @return {?}
     */
    AEMComponentDirective.prototype.setupPlaceholder = /**
     * Setups the placeholder of needed for the AEM editor
     *
     * @param {?} editConfig - the editConfig, which will dictate the classes to be added on.
     * @return {?}
     */
    function (editConfig) {
        if (this.usePlaceholder(editConfig)) {
            this.renderer.addClass(this._component.location.nativeElement, PLACEHOLDER_CLASS_NAME);
            this.renderer.setAttribute(this._component.location.nativeElement, "data-emptytext", editConfig.emptyLabel);
        }
        else {
            this.renderer.removeClass(this._component.location.nativeElement, PLACEHOLDER_CLASS_NAME);
            this.renderer.removeAttribute(this._component.location.nativeElement, "data-emptytext");
        }
    };
    /**
     * @return {?}
     */
    AEMComponentDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.setupItemAttrs();
    };
    /**
     * @return {?}
     */
    AEMComponentDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._component && this._component.destroy();
    };
    AEMComponentDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[aemComponent]'
                },] },
    ];
    /** @nocollapse */
    AEMComponentDirective.ctorParameters = function () { return [
        { type: Renderer2, },
        { type: ViewContainerRef, },
        { type: ComponentFactoryResolver, },
        { type: NgZone, },
    ]; };
    AEMComponentDirective.propDecorators = {
        "cqItem": [{ type: Input },],
        "cqPath": [{ type: Input },],
        "itemName": [{ type: Input },],
        "itemAttrs": [{ type: Input },],
        "aemComponent": [{ type: Input },],
    };
    return AEMComponentDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ PLACEHOLDER_CLASS_NAMES = Constants$1.NEW_SECTION_CLASS_NAMES;
var /** @type {?} */ PLACEHOLDER_ITEM_NAME = '*';
var /** @type {?} */ CONTAINER_CLASS_NAMES = 'aem-container';
var AEMContainerComponent = /** @class */ (function () {
    function AEMContainerComponent() {
        /**
         * Path to the model associated with the current instance of the component
         */
        this.cqPath = '';
        /**
         * Key of the model structure
         */
        this.modelName = '';
    }
    Object.defineProperty(AEMContainerComponent.prototype, "isInEditMode", {
        /**
         * Returns weather of not we are in the editor
         */
        get: /**
         * Returns weather of not we are in the editor
         * @return {?}
         */
        function () {
            return Utils.isInEditor();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param path - the provided path to aggregate with the container path
     */
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    AEMContainerComponent.prototype.getDataPath = /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    function (path) {
        return this.cqPath ? this.cqPath + '/' + path : path;
    };
    /**
     * Returns the item data from the cqModel
     *
     * @param itemKey - the itemKey to look for in the items.
     */
    /**
     * Returns the item data from the cqModel
     *
     * @param {?} itemKey - the itemKey to look for in the items.
     * @return {?}
     */
    AEMContainerComponent.prototype.getItem = /**
     * Returns the item data from the cqModel
     *
     * @param {?} itemKey - the itemKey to look for in the items.
     * @return {?}
     */
    function (itemKey) {
        return this.cqItems && this.cqItems[itemKey];
    };
    /**
     * Returns the class names of the container based on the data from the cqModel
     */
    /**
     * Returns the class names of the container based on the data from the cqModel
     * @return {?}
     */
    AEMContainerComponent.prototype.getHostClassNames = /**
     * Returns the class names of the container based on the data from the cqModel
     * @return {?}
     */
    function () {
        return CONTAINER_CLASS_NAMES;
    };
    Object.defineProperty(AEMContainerComponent.prototype, "hostClasses", {
        get: /**
         * @return {?}
         */
        function () {
            return this.getHostClassNames();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the placeholder classes
     */
    /**
     * Returns the placeholder classes
     * @return {?}
     */
    AEMContainerComponent.prototype.getPlaceholderClassNames = /**
     * Returns the placeholder classes
     * @return {?}
     */
    function () {
        return PLACEHOLDER_CLASS_NAMES;
    };
    Object.defineProperty(AEMContainerComponent.prototype, "placeholderPath", {
        /**
         * Returns the placeholder path
         */
        get: /**
         * Returns the placeholder path
         * @return {?}
         */
        function () {
            return this.cqPath && this.cqPath + '/' + PLACEHOLDER_ITEM_NAME;
        },
        enumerable: true,
        configurable: true
    });
    AEMContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aem-container',
                    host: {
                        '[class]': 'hostClasses',
                        '[attr.data-cq-data-path]': 'cqPath'
                    },
                    template: "<ng-container *ngFor=\"let itemKey of cqItemsOrder\">\n  <ng-container [aemComponent] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey'></ng-container>\n  <div *ngIf=\"isInEditMode\" [attr.data-cq-data-path]=\"placeholderPath\" [class]=\"getPlaceholderClassNames()\"></div>\n</ng-container>\n"
                },] },
    ];
    /** @nocollapse */
    AEMContainerComponent.propDecorators = {
        "cqItems": [{ type: Input },],
        "cqItemsOrder": [{ type: Input },],
        "cqPath": [{ type: Input },],
        "modelName": [{ type: Input },],
        "classNames": [{ type: Input },],
    };
    return AEMContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ PLACEHOLDER_CLASS_NAMES$1 = ' aem-Grid-newComponent';
var /** @type {?} */ RESPONSIVE_GRID_TYPE = 'wcm/foundation/components/responsivegrid';
var AEMResponsiveGridComponent = /** @class */ (function (_super) {
    __extends(AEMResponsiveGridComponent, _super);
    function AEMResponsiveGridComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the column class names for a given column
     * @param itemKey - The key of the column item
     */
    /**
     * Returns the column class names for a given column
     * @param {?} itemKey - The key of the column item
     * @return {?}
     */
    AEMResponsiveGridComponent.prototype.getColumnClassNames = /**
     * Returns the column class names for a given column
     * @param {?} itemKey - The key of the column item
     * @return {?}
     */
    function (itemKey) {
        return this.columnClassNames && this.columnClassNames[itemKey];
    };
    /**
     * Returns the placeholder classes
     */
    /**
     * Returns the placeholder classes
     * @return {?}
     */
    AEMResponsiveGridComponent.prototype.getPlaceholderClassNames = /**
     * Returns the placeholder classes
     * @return {?}
     */
    function () {
        return _super.prototype.getPlaceholderClassNames.call(this) + PLACEHOLDER_CLASS_NAMES$1;
    };
    /**
     * Returns the class names of the responsive grid based on the data from the cqModel
     */
    /**
     * Returns the class names of the responsive grid based on the data from the cqModel
     * @return {?}
     */
    AEMResponsiveGridComponent.prototype.getHostClassNames = /**
     * Returns the class names of the responsive grid based on the data from the cqModel
     * @return {?}
     */
    function () {
        var /** @type {?} */ classNames = _super.prototype.getHostClassNames.call(this);
        if (this.classNames) {
            classNames += ' ' + (this.classNames || '');
        }
        return classNames + ' ' + this.gridClassNames;
    };
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param path - the provided path to aggregate with the container path
     */
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    AEMResponsiveGridComponent.prototype.getAttrDataPath = /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    function (path) {
        var /** @type {?} */ item = this.getItem(path);
        if (item && item[Constants$1.TYPE_PROP] === RESPONSIVE_GRID_TYPE) {
            // We don't want to add the path for the wrapper for a reponsivegrid
            // The reponsivegrid adds the path on it's own
            return null;
        }
        return this.getDataPath(path);
    };
    AEMResponsiveGridComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aem-responsivegrid',
                    host: {
                        '[class]': 'hostClasses',
                        '[attr.data-cq-data-path]': 'cqPath'
                    },
                    template: "<ng-container *ngFor=\"let itemKey of cqItemsOrder\">\n  <div [aemModelProvider] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey' [class]=\"getColumnClassNames(itemKey)\" [attr.data-cq-data-path]='getAttrDataPath(itemKey)'>\n  </div>\n</ng-container>\n<div *ngIf=\"isInEditMode\" [attr.data-cq-data-path]=\"placeholderPath\" [class]=\"getPlaceholderClassNames()\"></div>\n\n\n",
                },] },
    ];
    /** @nocollapse */
    AEMResponsiveGridComponent.propDecorators = {
        "gridClassNames": [{ type: Input },],
        "columnClassNames": [{ type: Input },],
        "classNames": [{ type: Input },],
        "columnCount": [{ type: Input },],
    };
    return AEMResponsiveGridComponent;
}(AEMContainerComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AEMModelProviderComponent = /** @class */ (function () {
    function AEMModelProviderComponent(ngZone) {
        this.ngZone = ngZone;
    }
    /**
     * Updates the item data
     */
    /**
     * Updates the item data
     * @return {?}
     */
    AEMModelProviderComponent.prototype.updateItem = /**
     * Updates the item data
     * @return {?}
     */
    function () {
        var _this = this;
        ModelManager.getData({ path: this.cqPath }).then(function (model) {
            _this.ngZone.run(function () {
                _this.cqItem = model;
            });
        });
    };
    /**
     * @return {?}
     */
    AEMModelProviderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        ModelManager.addListener(this.cqPath, this.updateItem.bind(this));
    };
    /**
     * @return {?}
     */
    AEMModelProviderComponent.prototype.ngDestroy = /**
     * @return {?}
     */
    function () {
        ModelManager.removeListener(this.cqPath, this.updateItem.bind(this));
    };
    AEMModelProviderComponent.decorators = [
        { type: Component, args: [{
                    selector: '[aemModelProvider]',
                    template: "<ng-container [aemComponent] [cqItem]='cqItem' [cqPath]='cqPath' [itemName]='itemName'></ng-container>"
                },] },
    ];
    /** @nocollapse */
    AEMModelProviderComponent.ctorParameters = function () { return [
        { type: NgZone, },
    ]; };
    AEMModelProviderComponent.propDecorators = {
        "cqPath": [{ type: Input },],
        "cqItem": [{ type: Input },],
        "itemName": [{ type: Input },],
        "aemModelProvider": [{ type: Input },],
    };
    return AEMModelProviderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ PAGE_MODEL_SEPARATOR = '/jcr:content/';
var AEMPageComponent = /** @class */ (function (_super) {
    __extends(AEMPageComponent, _super);
    function AEMPageComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param path - the provided path to aggregate with the container path
     */
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    AEMPageComponent.prototype.getDataPath = /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    function (path) {
        return this.cqPath ? this.cqPath + PAGE_MODEL_SEPARATOR + path : path;
    };
    AEMPageComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aem-page',
                    host: {
                        '[class]': 'hostClasses',
                        '[attr.data-cq-data-path]': 'cqPath'
                    },
                    template: "<ng-container *ngFor=\"let itemKey of cqItemsOrder\">\n  <ng-container [aemComponent] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey'></ng-container>\n  <div *ngIf=\"isInEditMode\" [attr.data-cq-data-path]=\"placeholderPath\" [class]=\"getPlaceholderClassNames()\"></div>\n</ng-container>\n"
                },] },
    ];
    return AEMPageComponent;
}(AEMContainerComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SpaAngularEditableComponentsModule = /** @class */ (function () {
    function SpaAngularEditableComponentsModule() {
    }
    SpaAngularEditableComponentsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [AEMContainerComponent, AEMResponsiveGridComponent, AEMComponentDirective, AEMModelProviderComponent, AEMPageComponent],
                    exports: [AEMContainerComponent, AEMResponsiveGridComponent, AEMComponentDirective, AEMModelProviderComponent, AEMPageComponent],
                    entryComponents: [AEMContainerComponent, AEMResponsiveGridComponent, AEMPageComponent]
                },] },
    ];
    return SpaAngularEditableComponentsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AemPageDataResolver = /** @class */ (function () {
    function AemPageDataResolver() {
    }
    /**
     * Returns the absolute resource path without extension.
     * @example
     * // returns: '/content/aa/bb' for route.url [ 'content', 'aa', 'bb.html' ]
     * resolve(route)
     * @param route - route
     * @returns absolute resource path without extension
     */
    /**
     * Returns the absolute resource path without extension.
     * \@example
     * // returns: '/content/aa/bb' for route.url [ 'content', 'aa', 'bb.html' ]
     * resolve(route)
     * @param {?} route - route
     * @return {?} absolute resource path without extension
     */
    AemPageDataResolver.prototype.resolve = /**
     * Returns the absolute resource path without extension.
     * \@example
     * // returns: '/content/aa/bb' for route.url [ 'content', 'aa', 'bb.html' ]
     * resolve(route)
     * @param {?} route - route
     * @return {?} absolute resource path without extension
     */
    function (route) {
        return '/' + route.url.join('/').replace(/\.[^/.]+$/, '');
    };
    AemPageDataResolver.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    AemPageDataResolver.ctorParameters = function () { return []; };
    return AemPageDataResolver;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Implements RouteReuseStrategy to customize route reuse.
 */
var  /**
 * Implements RouteReuseStrategy to customize route reuse.
 */
AemPageRouteReuseStrategy = /** @class */ (function () {
    function AemPageRouteReuseStrategy() {
    }
    /** Determines if this route (and its subtree) should be detached to be reused later. */
    /**
     * Determines if this route (and its subtree) should be detached to be reused later.
     * @param {?} route
     * @return {?}
     */
    AemPageRouteReuseStrategy.prototype.shouldDetach = /**
     * Determines if this route (and its subtree) should be detached to be reused later.
     * @param {?} route
     * @return {?}
     */
    function (route) {
        return false;
    };
    /** Not storing deteached route. */
    /**
     * Not storing deteached route.
     * @param {?} route
     * @param {?} detachedTree
     * @return {?}
     */
    AemPageRouteReuseStrategy.prototype.store = /**
     * Not storing deteached route.
     * @param {?} route
     * @param {?} detachedTree
     * @return {?}
     */
    function (route, detachedTree) { };
    /** Determines if this route (and its subtree) should be reattached. */
    /**
     * Determines if this route (and its subtree) should be reattached.
     * @param {?} route
     * @return {?}
     */
    AemPageRouteReuseStrategy.prototype.shouldAttach = /**
     * Determines if this route (and its subtree) should be reattached.
     * @param {?} route
     * @return {?}
     */
    function (route) {
        return false;
    };
    /** Retrieves the previously stored route. */
    /**
     * Retrieves the previously stored route.
     * @param {?} route
     * @return {?}
     */
    AemPageRouteReuseStrategy.prototype.retrieve = /**
     * Retrieves the previously stored route.
     * @param {?} route
     * @return {?}
     */
    function (route) {
        return null;
    };
    /** Determines if a route should be reused */
    /**
     * Determines if a route should be reused
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    AemPageRouteReuseStrategy.prototype.shouldReuseRoute = /**
     * Determines if a route should be reused
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    function (future, curr) {
        return false;
    };
    return AemPageRouteReuseStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { AEMComponentDirective, AEMContainerComponent, AEMResponsiveGridComponent, ComponentMappingWithConfig, componentMapping as ComponentMapping, MapTo, Constants$1 as Constants, Utils, SpaAngularEditableComponentsModule, AemPageDataResolver, AemPageRouteReuseStrategy, AEMModelProviderComponent as ɵa, AEMPageComponent as ɵb };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRvYmUtY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvY29tcG9uZW50LW1hcHBpbmcudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2xheW91dC9jb25zdGFudHMudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2xheW91dC91dGlscy50cyIsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvbGF5b3V0L2FlbS1jb21wb25lbnQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvYWVtLWNvbnRhaW5lci9hZW0tY29udGFpbmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvbGF5b3V0L2FlbS1yZXNwb25zaXZlZ3JpZC9hZW0tcmVzcG9uc2l2ZWdyaWQuY29tcG9uZW50LnRzIiwibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvYWVtLW1vZGVsLXByb3ZpZGVyL2FlbS1tb2RlbC1wcm92aWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2xheW91dC9hZW0tcGFnZS9hZW0tcGFnZS5jb21wb25lbnQudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy5tb2R1bGUudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL3JvdXRpbmcvQWVtUGFnZURhdGFSZXNvbHZlci50cyIsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvcm91dGluZy9BZW1QYWdlUm91dGVSZXVzZVN0cmF0ZWd5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnRNYXBwaW5nIGFzIFNQQUNvbXBvbmVudE1hcHBpbmcgfSBmcm9tICdAYWRvYmUvY3Etc3BhLWNvbXBvbmVudC1tYXBwaW5nJztcblxuLyoqXG4gKiBUaGUgY3VycmVudCBjbGFzcyBleHRlbmRzIHRoZSBAYWRvYmUvY3Etc3BhLWNvbXBvbmVudC1tYXBwaW5nI01hcHRvIGxpYnJhcnkgYW5kIGZlYXR1cmVzIHdpdGggQW5ndWxhciBzcGVjaWZpY3Mgc3VjaCBhc1xuICpcbiAqIC0gU3RvcmluZyB0aGUgZWRpdGluZyBjb25maWd1cmF0aW9ucyBmb3IgZWFjaCByZXNvdXJjZSB0eXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRNYXBwaW5nV2l0aENvbmZpZyB7XG4gIC8qKlxuICAgKiBTdG9yZSBvZiBFZGl0Q29uZmlnIHN0cnVjdHVyZXNcbiAgICovXG4gIHByaXZhdGUgZWRpdENvbmZpZ01hcCA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3BhTWFwcGluZzpTUEFDb21wb25lbnRNYXBwaW5nKSB7fVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBjb21wb25lbnQgY2xhc3MgZm9yIHRoZSBnaXZlbiByZXNvdXJjZSB0eXBlcyBhbmQgYWxzbyBhbGxvd3MgdG8gcHJvdmlkZSBhbiBFZGl0Q29uZmlnIG9iamVjdFxuICAgKiBAcGFyYW0gcmVzb3VyY2VUeXBlcyAtIExpc3Qgb2YgcmVzb3VyY2UgdHlwZXNcbiAgICogQHBhcmFtIGNsYXp6IC0gQ29tcG9uZW50IGNsYXNzIHRvIGJlIHN0b3JlZFxuICAgKiBAcGFyYW0gW2VkaXRDb25maWddIC0gRWRpdCBjb25maWd1cmF0aW9uIHRvIGJlIHN0b3JlZCBmb3IgdGhlIGdpdmVuIHJlc291cmNlIHR5cGVzXG4gICAqL1xuICBtYXAocmVzb3VyY2VUeXBlcywgY2xhenosIGVkaXRDb25maWcgPSBudWxsKSB7XG4gICAgICBsZXQgaW5uZXJDbGFzcyA9IGNsYXp6O1xuXG4gICAgICBpZiAoZWRpdENvbmZpZykge1xuICAgICAgICAgIHRoaXMuZWRpdENvbmZpZ01hcFtyZXNvdXJjZVR5cGVzXSA9IGVkaXRDb25maWc7XG4gICAgICB9XG4gICAgICB0aGlzLnNwYU1hcHBpbmcubWFwKHJlc291cmNlVHlwZXMsIGlubmVyQ2xhc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgY2xhc3MgZm9yIHRoZSBnaXZlbiByZXNvdXJjZVR5cGVcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZSAtIFJlc291cmNlIHR5cGUgZm9yIHdoaWNoIHRoZSBjb21wb25lbnQgY2xhc3MgaGFzIGJlZW4gc3RvcmVkXG4gICAqL1xuICBnZXQocmVzb3VyY2VUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BhTWFwcGluZy5nZXQocmVzb3VyY2VUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBFZGl0Q29uZmlnIHN0cnVjdHVyZSBmb3IgdGhlIGdpdmVuIHR5cGVcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZSAtIFJlc291cmNlIHR5cGUgZm9yIHdoaWNoIHRoZSBjb25maWd1cmF0aW9uIGhhcyBiZWVuIHN0b3JlZFxuICAgKi9cbiAgZ2V0RWRpdENvbmZpZyhyZXNvdXJjZVR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0Q29uZmlnTWFwW3Jlc291cmNlVHlwZV07XG4gIH1cbn1cblxubGV0IGNvbXBvbmVudE1hcHBpbmcgPSBuZXcgQ29tcG9uZW50TWFwcGluZ1dpdGhDb25maWcoU1BBQ29tcG9uZW50TWFwcGluZyk7XG5cbmZ1bmN0aW9uIE1hcFRvKHJlc291cmNlVHlwZXMpIHtcbiAgICByZXR1cm4gKGNsYXp6LCBlZGl0Q29uZmlnID0gbnVsbCkgPT4ge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50TWFwcGluZy5tYXAocmVzb3VyY2VUeXBlcywgY2xhenosIGVkaXRDb25maWcpO1xuICAgIH07XG59XG5cblxuZXhwb3J0IHsgY29tcG9uZW50TWFwcGluZyBhcyBDb21wb25lbnRNYXBwaW5nLCBNYXBUbyB9O1xuIiwiLypcbiAqIEFET0JFIENPTkZJREVOVElBTFxuICpcbiAqIENvcHlyaWdodCAyMDE4IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVElDRTogIEFsbCBpbmZvcm1hdGlvbiBjb250YWluZWQgaGVyZWluIGlzLCBhbmQgcmVtYWluc1xuICogdGhlIHByb3BlcnR5IG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHMgc3VwcGxpZXJzLFxuICogaWYgYW55LiAgVGhlIGludGVsbGVjdHVhbCBhbmQgdGVjaG5pY2FsIGNvbmNlcHRzIGNvbnRhaW5lZFxuICogaGVyZWluIGFyZSBwcm9wcmlldGFyeSB0byBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzXG4gKiBzdXBwbGllcnMgYW5kIG1heSBiZSBjb3ZlcmVkIGJ5IFUuUy4gYW5kIEZvcmVpZ24gUGF0ZW50cyxcbiAqIHBhdGVudHMgaW4gcHJvY2VzcywgYW5kIGFyZSBwcm90ZWN0ZWQgYnkgdHJhZGUgc2VjcmV0IG9yIGNvcHlyaWdodCBsYXcuXG4gKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcbiAqIGlzIHN0cmljdGx5IGZvcmJpZGRlbiB1bmxlc3MgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uIGlzIG9idGFpbmVkXG4gKiBmcm9tIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLlxuICovXG5cbmltcG9ydCB7Q29uc3RhbnRzIGFzIFBNQ29uc3RhbnRzfSBmcm9tICdAYWRvYmUvY3Etc3BhLXBhZ2UtbW9kZWwtbWFuYWdlcic7XG5cbmV4cG9ydCBjb25zdCBDb25zdGFudHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBuYW1lcyBhc3NvY2lhdGVkIHdpdGggYSBuZXcgc2VjdGlvbiBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIE5FV19TRUNUSU9OX0NMQVNTX05BTUVTOiAnbmV3IHNlY3Rpb24nLFxuXG4gICAgVFlQRV9QUk9QOiBQTUNvbnN0YW50cy5UWVBFX1BST1AsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGNoaWxkIGl0ZW1zIG9mIGFuIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIElURU1TX1BST1A6IFBNQ29uc3RhbnRzLklURU1TX1BST1AsXG5cbiAgICAvKipcbiAgICAgKiBPcmRlciBpbiB3aGljaCB0aGUgaXRlbXMgc2hvdWxkIGJlIGxpc3RlZFxuICAgICAqXG4gICAgICovXG4gICAgSVRFTVNfT1JERVJfUFJPUDogUE1Db25zdGFudHMuSVRFTVNfT1JERVJfUFJPUCxcblxuICAgIC8qKlxuICAgICAqIFBhdGggb2YgdGhlIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIFBBVEhfUFJPUDogUE1Db25zdGFudHMuUEFUSF9QUk9QLFxuXG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gb2YgYW4gaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgQ0hJTERSRU5fUFJPUDogUE1Db25zdGFudHMuQ0hJTERSRU5fUFJPUCxcblxuICAgIC8qKlxuICAgICAqIFBhdGggb2YgdGhlIHJlc291cmNlIGluIHRoZSBtb2RlbFxuICAgICAqXG4gICAgICovXG4gICAgREFUQV9QQVRIX1BST1A6ICc6ZGF0YVBhdGgnLFxuXG4gICAgLyoqXG4gICAgICogSGllcmFyY2hpY2FsIHR5cGUgb2YgdGhlIGl0ZW1cbiAgICAgKi9cbiAgICBISUVSQVJDSFlfVFlQRV9QUk9QOiBQTUNvbnN0YW50cy5ISUVSQVJDSFlfVFlQRV9QUk9QXG59O1xuIiwiLypcbiAqIEFET0JFIENPTkZJREVOVElBTFxuICpcbiAqIENvcHlyaWdodCAyMDE4IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVElDRTogIEFsbCBpbmZvcm1hdGlvbiBjb250YWluZWQgaGVyZWluIGlzLCBhbmQgcmVtYWluc1xuICogdGhlIHByb3BlcnR5IG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHMgc3VwcGxpZXJzLFxuICogaWYgYW55LiAgVGhlIGludGVsbGVjdHVhbCBhbmQgdGVjaG5pY2FsIGNvbmNlcHRzIGNvbnRhaW5lZFxuICogaGVyZWluIGFyZSBwcm9wcmlldGFyeSB0byBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzXG4gKiBzdXBwbGllcnMgYW5kIG1heSBiZSBjb3ZlcmVkIGJ5IFUuUy4gYW5kIEZvcmVpZ24gUGF0ZW50cyxcbiAqIHBhdGVudHMgaW4gcHJvY2VzcywgYW5kIGFyZSBwcm90ZWN0ZWQgYnkgdHJhZGUgc2VjcmV0IG9yIGNvcHlyaWdodCBsYXcuXG4gKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcbiAqIGlzIHN0cmljdGx5IGZvcmJpZGRlbiB1bmxlc3MgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uIGlzIG9idGFpbmVkXG4gKiBmcm9tIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLlxuICovXG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCBpZGVudGlmaWVzIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIFdDTSBtb2RlIHN0YXRlXG4gKi9cbmNvbnN0IFdDTV9NT0RFX01FVEFfU0VMRUNUT1I6c3RyaW5nID0gJ21ldGFbcHJvcGVydHk9XCJjcTp3Y21tb2RlXCJdJztcblxuLyoqXG4gKiBUaGUgZWRpdG9yIGlzIGluIG9uZSBvZiB0aGUgZWRpdGlvbiBtb2Rlc1xuICovXG5jb25zdCBFRElUX01PREU6c3RyaW5nID0gJ2VkaXQnO1xuXG4vKipcbiAqIFRoZSBlZGl0b3IgaXMgaW4gcHJldmlldyBtb2RlXG4gKi9cbmNvbnN0IFBSRVZJRVdfTU9ERTpzdHJpbmcgPSAncHJldmlldyc7XG4vKipcbiAqIFJldHVybnMgaWYgd2UgYXJlIGluIHRoZSBicm93c2VyIGNvbnRleHQgb3Igbm90IGJ5IGNoZWNraW5nIGZvciB0aGVcbiAqIGV4aXN0ZW5jZSBvZiB0aGUgd2luZG93IG9iamVjdFxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IFdDTSBtb2RlXG4gKlxuICogPHA+Tm90ZSB0aGF0IHRoZSB2YWx1ZSBpc24ndCwgYXMgb2YgdGhlIGRhdGUgb2YgdGhpcyB3cml0aW5nLCB1cGRhdGVkIGJ5IHRoZSBlZGl0b3I8L3A+XG4gKi9cbmZ1bmN0aW9uIGdldFdDTU1vZGUoKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICBjb25zdCB3Y21Nb2RlTWV0YTphbnkgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoV0NNX01PREVfTUVUQV9TRUxFQ1RPUik7XG4gICAgICByZXR1cm4gd2NtTW9kZU1ldGEgJiYgd2NtTW9kZU1ldGEuY29udGVudDtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgQUVNIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBVdGlscyA9IHtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBhcHAgdXNlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgQUVNIFBhZ2UgZWRpdG9yXG4gICAgICovXG4gICAgaXNJbkVkaXRvcigpIHtcbiAgICAgICAgY29uc3Qgd2NtTW9kZSA9IGdldFdDTU1vZGUoKTtcbiAgICAgICAgcmV0dXJuIHdjbU1vZGUgJiYgKEVESVRfTU9ERSA9PT0gd2NtTW9kZSB8fCBQUkVWSUVXX01PREUgPT09IHdjbU1vZGUpO1xuICAgIH1cbn07XG4iLCIvKlxuICogQURPQkUgQ09ORklERU5USUFMXG4gKlxuICogQ29weXJpZ2h0IDIwMTggQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWRcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTk9USUNFOiAgQWxsIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBoZXJlaW4gaXMsIGFuZCByZW1haW5zXG4gKiB0aGUgcHJvcGVydHkgb2YgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0cyBzdXBwbGllcnMsXG4gKiBpZiBhbnkuICBUaGUgaW50ZWxsZWN0dWFsIGFuZCB0ZWNobmljYWwgY29uY2VwdHMgY29udGFpbmVkXG4gKiBoZXJlaW4gYXJlIHByb3ByaWV0YXJ5IHRvIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHNcbiAqIHN1cHBsaWVycyBhbmQgbWF5IGJlIGNvdmVyZWQgYnkgVS5TLiBhbmQgRm9yZWlnbiBQYXRlbnRzLFxuICogcGF0ZW50cyBpbiBwcm9jZXNzLCBhbmQgYXJlIHByb3RlY3RlZCBieSB0cmFkZSBzZWNyZXQgb3IgY29weXJpZ2h0IGxhdy5cbiAqIERpc3NlbWluYXRpb24gb2YgdGhpcyBpbmZvcm1hdGlvbiBvciByZXByb2R1Y3Rpb24gb2YgdGhpcyBtYXRlcmlhbFxuICogaXMgc3RyaWN0bHkgZm9yYmlkZGVuIHVubGVzcyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24gaXMgb2J0YWluZWRcbiAqIGZyb20gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgUmVuZGVyZXIyLCBOZ1pvbmUsIFZpZXdDb250YWluZXJSZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENvbXBvbmVudE1hcHBpbmcgfSBmcm9tICcuL2NvbXBvbmVudC1tYXBwaW5nJztcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5cblxuY29uc3QgUExBQ0VIT0xERVJfQ0xBU1NfTkFNRSA9ICdjcS1wbGFjZWhvbGRlcic7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1thZW1Db21wb25lbnRdJ1xufSlcblxuLyoqXG4gKiBUaGUgY3VycmVudCBkaXJlY3RpdmUgcHJvdmlkZXMgYWR2YW5jZWQgY2FwYWJpbGl0aWVzIGFtb25nIHdoaWNoIGFyZVxuICpcbiAqIC0gVGhlIG1hbmFnZW1lbnQgb2YgdGhlIGNvbXBvbmVudCBwbGFjZWhvbGRlciBpbiB0aGUgUGFnZSBFZGl0b3JcbiAqIC0gVGhlIGR5bmFtaWMgaW5zdGFudGlhdGlvbiBvZiBjb21wb25lbnRzIGJhc2VkIG9uIGEgY29tcG9uZW50IGRlZmluaXRpb25cbiAqIC0gVGhlIGNvbnZlcnNpb24gZnJvbSBtb2RlbCBmaWVsZHMgdG8gcHJvcGVydGllcyBhbmQgaW5qZWN0aW9uIGluIHRoZSBjb21wb25lbnQgaW5zdGFuY2VcbiAqIC0gVGhlIG1hbmFnZW1lbnQgb2YgSFRNTEVsZW1lbnQgYXR0cmlidXRlcyBhbmQgY2xhc3MgbmFtZXMgb24gdGhlIG5hdGl2ZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBBRU1Db21wb25lbnREaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgLyoqXG4gICAqIER5bmFtaWNhbGx5IGNyZWF0ZWQgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIF9jb21wb25lbnQ6Q29tcG9uZW50UmVmPGFueT47XG4gIC8qKlxuICAgKiBNb2RlbCBpdGVtIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIF9jcUl0ZW06b2JqZWN0O1xuXG4gIGdldCBjcUl0ZW0oKTogb2JqZWN0IHtcbiAgICByZXR1cm4gdGhpcy5fY3FJdGVtO1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IGNxSXRlbSh2YWx1ZTogb2JqZWN0KSB7XG4gICAgdGhpcy5fY3FJdGVtID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnREYXRhKCk7XG4gIH1cblxuICAvKipcbiAgICogUGF0aCB0byB0aGUgbW9kZWwgc3RydWN0dXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGNxUGF0aDpzdHJpbmc7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGl0ZW1OYW1lOnN0cmluZztcbiAgLyoqXG4gICAqIEh0bWxFbGVtZW50IGF0dHJpYnV0ZXMgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGl0ZW1BdHRyczogb2JqZWN0O1xuXG4gIEBJbnB1dCgpIGFlbUNvbXBvbmVudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgZmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5yZW5kZXJDb21wb25lbnQoQ29tcG9uZW50TWFwcGluZy5nZXQodGhpcy50eXBlKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgY3FJdGVtIGlmIGV4aXN0cy5cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNxSXRlbSAmJiB0aGlzLmNxSXRlbVtDb25zdGFudHMuVFlQRV9QUk9QXTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBhIGNvbXBvbmVudCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb25cbiAgICpcbiAgICogQHBhcmFtIGNvbXBvbmVudERlZmluaXRpb24gVGhlIGNvbXBvbmVudCBkZWZpbml0aW9uIHRvIHJlbmRlclxuICAgKi9cbiAgcHJpdmF0ZSByZW5kZXJDb21wb25lbnQoY29tcG9uZW50RGVmaW5pdGlvbjphbnkpIHtcbiAgICBpZiAoY29tcG9uZW50RGVmaW5pdGlvbikge1xuICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudERlZmluaXRpb24pO1xuICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB0aGlzLl9jb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnREYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRhdGEgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB0aGUgZGF0YSBvZiB0aGUgZGlyZWN0aXZlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUNvbXBvbmVudERhdGEoKSB7XG4gICAgaWYgKCF0aGlzLl9jb21wb25lbnQgfHwgIXRoaXMuX2NvbXBvbmVudC5pbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5jcUl0ZW0pO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHByb3BLZXkgPSBrZXk7XG5cbiAgICAgICAgaWYgKHByb3BLZXkuc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybWF0aW9uIG9mIGludGVybmFsIHByb3BlcnRpZXMgbmFtZXNwYWNlZCB3aXRoIFs6XSB0byBbY3FdXG4gICAgICAgICAgICAvLyA6bXlQcm9wZXJ0eSA9PiBjcU15UHJvcGVydHlcbiAgICAgICAgICAgIGxldCB0ZW1wS2V5ID0gcHJvcEtleS5zdWJzdHIoMSk7XG4gICAgICAgICAgICBwcm9wS2V5ID0gXCJjcVwiICsgdGVtcEtleS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHRlbXBLZXkuc3Vic3RyKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29tcG9uZW50Lmluc3RhbmNlW3Byb3BLZXldID0gdGhpcy5jcUl0ZW1ba2V5XTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NvbXBvbmVudC5pbnN0YW5jZS5jcVBhdGggPSB0aGlzLmNxUGF0aDtcbiAgICB0aGlzLl9jb21wb25lbnQuaW5zdGFuY2UuaXRlbU5hbWUgPSB0aGlzLml0ZW1OYW1lO1xuICAgIGxldCBlZGl0Q29uZmlnID0gQ29tcG9uZW50TWFwcGluZy5nZXRFZGl0Q29uZmlnKHRoaXMudHlwZSk7XG4gICAgaWYgKGVkaXRDb25maWcgJiYgVXRpbHMuaXNJbkVkaXRvcikge1xuICAgICAgdGhpcy5zZXR1cFBsYWNlaG9sZGVyKGVkaXRDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgaXRlbSBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIHNldHVwSXRlbUF0dHJzKCkge1xuICAgIGlmICh0aGlzLml0ZW1BdHRycykge1xuICAgICAgbGV0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLml0ZW1BdHRycyk7XG5cbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgIGxldCBjbGFzc2VzID0gdGhpcy5pdGVtQXR0cnNba2V5XS5zcGxpdCgnICcpO1xuICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaCgoaXRlbUNsYXNzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBpdGVtQ2xhc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBrZXkgLCB0aGlzLml0ZW1BdHRyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBlIGRpc3BsYXllZC5cbiAgICpcbiAgICogQHBhcmFtIGVkaXRDb25maWcgLSB0aGUgZWRpdCBjb25maWcgb2YgdGhlIGRpcmVjdGl2ZVxuICAgKi9cbiAgcHJpdmF0ZSB1c2VQbGFjZWhvbGRlcihlZGl0Q29uZmlnKSB7XG4gICAgcmV0dXJuIGVkaXRDb25maWcuaXNFbXB0eSAmJiB0eXBlb2YgZWRpdENvbmZpZy5pc0VtcHR5ID09PSBcImZ1bmN0aW9uXCIgJiYgZWRpdENvbmZpZy5pc0VtcHR5KHRoaXMuY3FJdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cHMgdGhlIHBsYWNlaG9sZGVyIG9mIG5lZWRlZCBmb3IgdGhlIEFFTSBlZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIGVkaXRDb25maWcgLSB0aGUgZWRpdENvbmZpZywgd2hpY2ggd2lsbCBkaWN0YXRlIHRoZSBjbGFzc2VzIHRvIGJlIGFkZGVkIG9uLlxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cFBsYWNlaG9sZGVyKGVkaXRDb25maWcpIHtcbiAgICBpZiAodGhpcy51c2VQbGFjZWhvbGRlcihlZGl0Q29uZmlnKSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBQTEFDRUhPTERFUl9DTEFTU19OQU1FKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIFwiZGF0YS1lbXB0eXRleHRcIiwgZWRpdENvbmZpZy5lbXB0eUxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBQTEFDRUhPTERFUl9DTEFTU19OQU1FKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5fY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIFwiZGF0YS1lbXB0eXRleHRcIik7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuc2V0dXBJdGVtQXR0cnMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2NvbXBvbmVudCAmJiB0aGlzLl9jb21wb25lbnQuZGVzdHJveSgpO1xuICB9XG5cbn1cbiIsIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gXCIuLi91dGlsc1wiO1xuXG5jb25zdCBQTEFDRUhPTERFUl9DTEFTU19OQU1FUyA9IENvbnN0YW50cy5ORVdfU0VDVElPTl9DTEFTU19OQU1FUztcbmNvbnN0IFBMQUNFSE9MREVSX0lURU1fTkFNRSA9ICcqJztcbmNvbnN0IENPTlRBSU5FUl9DTEFTU19OQU1FUyA9ICdhZW0tY29udGFpbmVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYWVtLWNvbnRhaW5lcicsXG4gIGhvc3Q6IHtcbiAgICAgICdbY2xhc3NdJzogJ2hvc3RDbGFzc2VzJyxcbiAgICAgICdbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF0nOidjcVBhdGgnXG4gIH0sXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbUtleSBvZiBjcUl0ZW1zT3JkZXJcIj5cbiAgPG5nLWNvbnRhaW5lciBbYWVtQ29tcG9uZW50XSBbY3FJdGVtXT0nZ2V0SXRlbShpdGVtS2V5KScgW2NxUGF0aF09J2dldERhdGFQYXRoKGl0ZW1LZXkpJyBbaXRlbU5hbWVdPSdpdGVtS2V5Jz48L25nLWNvbnRhaW5lcj5cbiAgPGRpdiAqbmdJZj1cImlzSW5FZGl0TW9kZVwiIFthdHRyLmRhdGEtY3EtZGF0YS1wYXRoXT1cInBsYWNlaG9sZGVyUGF0aFwiIFtjbGFzc109XCJnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKVwiPjwvZGl2PlxuPC9uZy1jb250YWluZXI+XG5gXG59KVxuLyoqXG4gKiBUaGUgY3VycmVudCBjb21wb25lbnQgcHJvdmlkZXMgdGhlIGJhc2UgcHJlc2VudGF0aW9uYWwgbG9naWMgY29tbW9uIHRvIGNvbnRhaW5lcnMgc3VjaCBhcyBhIGdyaWQgb3IgYSBwYWdlLlxuICogQ29udGFpbmVyIGhhdmUgaW4gY29tbW9uIHRoZSBub3Rpb24gb2YgaXRlbSBob2xkZXJzLiBJdGVtcyBhcmUgcmVwcmVzZW50ZWQgaW4gdGhlIG1vZGVsIGJ5IHRoZSBmaWVsZHMgXzppdGVtc18gYW5kIF86aXRlbXNPcmRlcl9cbiAqL1xuZXhwb3J0IGNsYXNzIEFFTUNvbnRhaW5lckNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBNYXAgb2YgbW9kZWwgaXRlbXMgaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgY29udGFpbmVyXG4gICAqL1xuICBASW5wdXQoKSBjcUl0ZW1zO1xuICAvKipcbiAgICogQXJyYXkgb2YgbW9kZWwgaXRlbSBrZXlzXG4gICAqL1xuICBASW5wdXQoKSBjcUl0ZW1zT3JkZXI7XG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY3FQYXRoOnN0cmluZyA9ICcnO1xuICAvKipcbiAgICogS2V5IG9mIHRoZSBtb2RlbCBzdHJ1Y3R1cmVcbiAgICovXG4gIEBJbnB1dCgpIG1vZGVsTmFtZTpzdHJpbmcgPSAnJztcbiAgLyoqXG4gICAqIENsYXNzIG5hbWVzIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY2xhc3NOYW1lczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdlYXRoZXIgb2Ygbm90IHdlIGFyZSBpbiB0aGUgZWRpdG9yXG4gICAqL1xuICBnZXQgaXNJbkVkaXRNb2RlKCkge1xuICAgIHJldHVybiBVdGlscy5pc0luRWRpdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWdncmVnYXRlZCBwYXRoIG9mIHRoaXMgY29udGFpbmVyIHBhdGggYW5kIHRoZSBwcm92aWRlZCBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIC0gdGhlIHByb3ZpZGVkIHBhdGggdG8gYWdncmVnYXRlIHdpdGggdGhlIGNvbnRhaW5lciBwYXRoXG4gICAqL1xuICBnZXREYXRhUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3FQYXRoID8gdGhpcy5jcVBhdGggKyAnLycgKyBwYXRoIDogcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVtIGRhdGEgZnJvbSB0aGUgY3FNb2RlbFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbUtleSAtIHRoZSBpdGVtS2V5IHRvIGxvb2sgZm9yIGluIHRoZSBpdGVtcy5cbiAgICovXG4gIGdldEl0ZW0oaXRlbUtleSkge1xuICAgIHJldHVybiB0aGlzLmNxSXRlbXMgJiYgdGhpcy5jcUl0ZW1zW2l0ZW1LZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWVzIG9mIHRoZSBjb250YWluZXIgYmFzZWQgb24gdGhlIGRhdGEgZnJvbSB0aGUgY3FNb2RlbFxuICAgKi9cbiAgZ2V0SG9zdENsYXNzTmFtZXMoKSB7XG4gICAgcmV0dXJuIENPTlRBSU5FUl9DTEFTU19OQU1FUztcbiAgfVxuXG4gIGdldCBob3N0Q2xhc3NlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SG9zdENsYXNzTmFtZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjbGFzc2VzXG4gICAqL1xuICBnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKSB7XG4gICAgcmV0dXJuIFBMQUNFSE9MREVSX0NMQVNTX05BTUVTO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHBhdGhcbiAgICovXG4gIGdldCBwbGFjZWhvbGRlclBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3FQYXRoICYmIHRoaXMuY3FQYXRoICsgJy8nICsgUExBQ0VIT0xERVJfSVRFTV9OQU1FO1xuICB9XG59XG5cbiIsIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBRU1Db250YWluZXJDb21wb25lbnQgfSBmcm9tICcuLi9hZW0tY29udGFpbmVyL2FlbS1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IFBMQUNFSE9MREVSX0NMQVNTX05BTUVTID0gJyBhZW0tR3JpZC1uZXdDb21wb25lbnQnO1xuY29uc3QgUkVTUE9OU0lWRV9HUklEX1RZUEUgPSAnd2NtL2ZvdW5kYXRpb24vY29tcG9uZW50cy9yZXNwb25zaXZlZ3JpZCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2FlbS1yZXNwb25zaXZlZ3JpZCcsXG4gIGhvc3Q6IHtcbiAgICAgICdbY2xhc3NdJzogJ2hvc3RDbGFzc2VzJyxcbiAgICAgICdbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF0nOidjcVBhdGgnXG4gIH0sXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbUtleSBvZiBjcUl0ZW1zT3JkZXJcIj5cbiAgPGRpdiBbYWVtTW9kZWxQcm92aWRlcl0gW2NxSXRlbV09J2dldEl0ZW0oaXRlbUtleSknIFtjcVBhdGhdPSdnZXREYXRhUGF0aChpdGVtS2V5KScgW2l0ZW1OYW1lXT0naXRlbUtleScgW2NsYXNzXT1cImdldENvbHVtbkNsYXNzTmFtZXMoaXRlbUtleSlcIiBbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF09J2dldEF0dHJEYXRhUGF0aChpdGVtS2V5KSc+XG4gIDwvZGl2PlxuPC9uZy1jb250YWluZXI+XG48ZGl2ICpuZ0lmPVwiaXNJbkVkaXRNb2RlXCIgW2F0dHIuZGF0YS1jcS1kYXRhLXBhdGhdPVwicGxhY2Vob2xkZXJQYXRoXCIgW2NsYXNzXT1cImdldFBsYWNlaG9sZGVyQ2xhc3NOYW1lcygpXCI+PC9kaXY+XG5cblxuYCxcbn0pXG4vKipcbiAqIFRoZSBjdXJyZW50IGNsYXNzIGNhcnJpZXMgdGhlIGJhc2UgcHJlc2VudGF0aW9uYWwgbG9naWMgb2YgdGhlIEFFTSBMYXlvdXQgQ29udGFpbmVyIChha2EuIFJlc3BvbnNpdmUgZ3JpZClcbiAqL1xuZXhwb3J0IGNsYXNzIEFFTVJlc3BvbnNpdmVHcmlkQ29tcG9uZW50IGV4dGVuZHMgQUVNQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENsYXNzIG5hbWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCByZXNwb25zaXZlIGdyaWRcbiAgICovXG4gIEBJbnB1dCgpIGdyaWRDbGFzc05hbWVzOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBNYXAgb2YgY2xhc3MgbmFtZXMgY29ycmVzcG9uZGluZyB0byBlYWNoIGNoaWxkIG9mIHRoZSBjdXJyZW50IHJlc3BvbnNpdmUgZ3JpZFxuICAgKi9cbiAgQElucHV0KCkgY29sdW1uQ2xhc3NOYW1lczogT2JqZWN0O1xuICAvKipcbiAgICogQ2xhc3MgbmFtZXMgb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50XG4gICAqL1xuICBASW5wdXQoKSBjbGFzc05hbWVzOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDdXJyZW50IG51bWJlciBvZiBjb2x1bW5zIG9mIHRoZSBncmlkXG4gICAqL1xuICBASW5wdXQoKSBjb2x1bW5Db3VudDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb2x1bW4gY2xhc3MgbmFtZXMgZm9yIGEgZ2l2ZW4gY29sdW1uXG4gICAqIEBwYXJhbSBpdGVtS2V5IC0gVGhlIGtleSBvZiB0aGUgY29sdW1uIGl0ZW1cbiAgICovXG4gIGdldENvbHVtbkNsYXNzTmFtZXMoaXRlbUtleTpzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5DbGFzc05hbWVzICYmIHRoaXMuY29sdW1uQ2xhc3NOYW1lc1tpdGVtS2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjbGFzc2VzXG4gICAqL1xuICBnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFBsYWNlaG9sZGVyQ2xhc3NOYW1lcygpICsgUExBQ0VIT0xERVJfQ0xBU1NfTkFNRVM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xhc3MgbmFtZXMgb2YgdGhlIHJlc3BvbnNpdmUgZ3JpZCBiYXNlZCBvbiB0aGUgZGF0YSBmcm9tIHRoZSBjcU1vZGVsXG4gICAqL1xuICBnZXRIb3N0Q2xhc3NOYW1lcygpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IHN1cGVyLmdldEhvc3RDbGFzc05hbWVzKCk7XG5cbiAgICBpZiAodGhpcy5jbGFzc05hbWVzKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgKz0gJyAnICsgKHRoaXMuY2xhc3NOYW1lcyB8fCAnJykgO1xuICAgIH1cblxuICAgIHJldHVybiBjbGFzc05hbWVzICsgJyAnICsgdGhpcy5ncmlkQ2xhc3NOYW1lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhZ2dyZWdhdGVkIHBhdGggb2YgdGhpcyBjb250YWluZXIgcGF0aCBhbmQgdGhlIHByb3ZpZGVkIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIHBhdGggLSB0aGUgcHJvdmlkZWQgcGF0aCB0byBhZ2dyZWdhdGUgd2l0aCB0aGUgY29udGFpbmVyIHBhdGhcbiAgICovXG4gIGdldEF0dHJEYXRhUGF0aChwYXRoKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLmdldEl0ZW0ocGF0aCk7XG4gICAgaWYgKGl0ZW0gJiYgaXRlbVtDb25zdGFudHMuVFlQRV9QUk9QXSA9PT0gUkVTUE9OU0lWRV9HUklEX1RZUEUpIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWRkIHRoZSBwYXRoIGZvciB0aGUgd3JhcHBlciBmb3IgYSByZXBvbnNpdmVncmlkXG4gICAgICAvLyBUaGUgcmVwb25zaXZlZ3JpZCBhZGRzIHRoZSBwYXRoIG9uIGl0J3Mgb3duXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXREYXRhUGF0aChwYXRoKTtcbiAgfVxufVxuIiwiLypcbiAqIEFET0JFIENPTkZJREVOVElBTFxuICpcbiAqIENvcHlyaWdodCAyMDE4IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVElDRTogIEFsbCBpbmZvcm1hdGlvbiBjb250YWluZWQgaGVyZWluIGlzLCBhbmQgcmVtYWluc1xuICogdGhlIHByb3BlcnR5IG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHMgc3VwcGxpZXJzLFxuICogaWYgYW55LiAgVGhlIGludGVsbGVjdHVhbCBhbmQgdGVjaG5pY2FsIGNvbmNlcHRzIGNvbnRhaW5lZFxuICogaGVyZWluIGFyZSBwcm9wcmlldGFyeSB0byBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzXG4gKiBzdXBwbGllcnMgYW5kIG1heSBiZSBjb3ZlcmVkIGJ5IFUuUy4gYW5kIEZvcmVpZ24gUGF0ZW50cyxcbiAqIHBhdGVudHMgaW4gcHJvY2VzcywgYW5kIGFyZSBwcm90ZWN0ZWQgYnkgdHJhZGUgc2VjcmV0IG9yIGNvcHlyaWdodCBsYXcuXG4gKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcbiAqIGlzIHN0cmljdGx5IGZvcmJpZGRlbiB1bmxlc3MgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uIGlzIG9idGFpbmVkXG4gKiBmcm9tIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTW9kZWxNYW5hZ2VyIH0gZnJvbSBcIkBhZG9iZS9jcS1zcGEtcGFnZS1tb2RlbC1tYW5hZ2VyXCI7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1thZW1Nb2RlbFByb3ZpZGVyXScsXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciBbYWVtQ29tcG9uZW50XSBbY3FJdGVtXT0nY3FJdGVtJyBbY3FQYXRoXT0nY3FQYXRoJyBbaXRlbU5hbWVdPSdpdGVtTmFtZSc+PC9uZy1jb250YWluZXI+YFxufSlcbi8qKlxuICogVGhlIGN1cnJlbnQgY29tcG9uZW50IGlzIHJlc3BvbnNpYmxlIGZvciBwcm92aWRpbmcgYWNjZXNzIHRvIHRoZSBNb2RlbE1hbmFnZXIgYW5kIHRoZSBtb2RlbCBvZiBhIGNvbXBvbmVudFxuICovXG5leHBvcnQgY2xhc3MgQUVNTW9kZWxQcm92aWRlckNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY3FQYXRoO1xuICAvKipcbiAgICogTW9kZWwgaXRlbSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbW9kZWwgcHJvdmlkZXIgY29tcG9uZW50XG4gICAqL1xuICBASW5wdXQoKSBjcUl0ZW07XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBpdGVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBtb2RlbCBwcm92aWRlciBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGl0ZW1OYW1lO1xuXG4gIEBJbnB1dCgpIGFlbU1vZGVsUHJvdmlkZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGl0ZW0gZGF0YVxuICAgKi9cbiAgdXBkYXRlSXRlbSgpIHtcbiAgICBNb2RlbE1hbmFnZXIuZ2V0RGF0YSh7cGF0aDogdGhpcy5jcVBhdGh9KS50aGVuKG1vZGVsID0+IHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNxSXRlbSA9IG1vZGVsO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIE1vZGVsTWFuYWdlci5hZGRMaXN0ZW5lcih0aGlzLmNxUGF0aCwgdGhpcy51cGRhdGVJdGVtLmJpbmQodGhpcykpO1xuICB9XG5cbiAgbmdEZXN0cm95KCkge1xuICAgIE1vZGVsTWFuYWdlci5yZW1vdmVMaXN0ZW5lcih0aGlzLmNxUGF0aCwgdGhpcy51cGRhdGVJdGVtLmJpbmQodGhpcykpO1xuICB9XG59XG5cbiIsIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFFTUNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4uL2FlbS1jb250YWluZXIvYWVtLWNvbnRhaW5lci5jb21wb25lbnQnO1xuXG5jb25zdCBQQUdFX01PREVMX1NFUEFSQVRPUiA9ICcvamNyOmNvbnRlbnQvJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYWVtLXBhZ2UnLFxuICBob3N0OiB7XG4gICAgICAnW2NsYXNzXSc6ICdob3N0Q2xhc3NlcycsXG4gICAgICAnW2F0dHIuZGF0YS1jcS1kYXRhLXBhdGhdJzonY3FQYXRoJ1xuICB9LFxuICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW1LZXkgb2YgY3FJdGVtc09yZGVyXCI+XG4gIDxuZy1jb250YWluZXIgW2FlbUNvbXBvbmVudF0gW2NxSXRlbV09J2dldEl0ZW0oaXRlbUtleSknIFtjcVBhdGhdPSdnZXREYXRhUGF0aChpdGVtS2V5KScgW2l0ZW1OYW1lXT0naXRlbUtleSc+PC9uZy1jb250YWluZXI+XG4gIDxkaXYgKm5nSWY9XCJpc0luRWRpdE1vZGVcIiBbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF09XCJwbGFjZWhvbGRlclBhdGhcIiBbY2xhc3NdPVwiZ2V0UGxhY2Vob2xkZXJDbGFzc05hbWVzKClcIj48L2Rpdj5cbjwvbmctY29udGFpbmVyPlxuYFxufSlcbi8qKlxuICogVGhlIGN1cnJlbnQgY29tcG9uZW50IGNhcnJpZXMgdGhlIGJhc2UgcHJlc2VudGF0aW9uYWwgbG9naWMgb2YgcGFnZSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEFFTVBhZ2VDb21wb25lbnQgZXh0ZW5kcyBBRU1Db250YWluZXJDb21wb25lbnQge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWdncmVnYXRlZCBwYXRoIG9mIHRoaXMgY29udGFpbmVyIHBhdGggYW5kIHRoZSBwcm92aWRlZCBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIC0gdGhlIHByb3ZpZGVkIHBhdGggdG8gYWdncmVnYXRlIHdpdGggdGhlIGNvbnRhaW5lciBwYXRoXG4gICAqL1xuICBnZXREYXRhUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3FQYXRoID8gdGhpcy5jcVBhdGggKyBQQUdFX01PREVMX1NFUEFSQVRPUiArIHBhdGggOiBwYXRoO1xuICB9XG5cbn1cblxuIiwiLypcbiAqICBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqICBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBRU1Db21wb25lbnREaXJlY3RpdmUgfSBmcm9tIFwiLi9sYXlvdXQvYWVtLWNvbXBvbmVudC5kaXJlY3RpdmVcIjtcbmltcG9ydCB7IEFFTU1vZGVsUHJvdmlkZXJDb21wb25lbnQgfSBmcm9tIFwiLi9sYXlvdXQvYWVtLW1vZGVsLXByb3ZpZGVyL2FlbS1tb2RlbC1wcm92aWRlci5jb21wb25lbnRcIjtcbmltcG9ydCB7IEFFTUNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gXCIuL2xheW91dC9hZW0tY29udGFpbmVyL2FlbS1jb250YWluZXIuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBRU1QYWdlQ29tcG9uZW50IH0gZnJvbSBcIi4vbGF5b3V0L2FlbS1wYWdlL2FlbS1wYWdlLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQUVNUmVzcG9uc2l2ZUdyaWRDb21wb25lbnQgfSBmcm9tIFwiLi9sYXlvdXQvYWVtLXJlc3BvbnNpdmVncmlkL2FlbS1yZXNwb25zaXZlZ3JpZC5jb21wb25lbnRcIjtcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuXG4gIGRlY2xhcmF0aW9uczogW0FFTUNvbnRhaW5lckNvbXBvbmVudCwgQUVNUmVzcG9uc2l2ZUdyaWRDb21wb25lbnQsIEFFTUNvbXBvbmVudERpcmVjdGl2ZSwgQUVNTW9kZWxQcm92aWRlckNvbXBvbmVudCwgQUVNUGFnZUNvbXBvbmVudF0sXG4gIGV4cG9ydHM6IFtBRU1Db250YWluZXJDb21wb25lbnQsIEFFTVJlc3BvbnNpdmVHcmlkQ29tcG9uZW50LCBBRU1Db21wb25lbnREaXJlY3RpdmUsIEFFTU1vZGVsUHJvdmlkZXJDb21wb25lbnQsIEFFTVBhZ2VDb21wb25lbnRdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtBRU1Db250YWluZXJDb21wb25lbnQsIEFFTVJlc3BvbnNpdmVHcmlkQ29tcG9uZW50LCBBRU1QYWdlQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBTcGFBbmd1bGFyRWRpdGFibGVDb21wb25lbnRzTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzb2x2ZSwgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBZW1QYWdlRGF0YVJlc29sdmVyIGltcGxlbWVudHMgUmVzb2x2ZSA8IHN0cmluZyA+IHtcbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhYnNvbHV0ZSByZXNvdXJjZSBwYXRoIHdpdGhvdXQgZXh0ZW5zaW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyByZXR1cm5zOiAnL2NvbnRlbnQvYWEvYmInIGZvciByb3V0ZS51cmwgWyAnY29udGVudCcsICdhYScsICdiYi5odG1sJyBdXG4gICAqIHJlc29sdmUocm91dGUpXG4gICAqIEBwYXJhbSByb3V0ZSAtIHJvdXRlXG4gICAqIEByZXR1cm5zIGFic29sdXRlIHJlc291cmNlIHBhdGggd2l0aG91dCBleHRlbnNpb25cbiAgICovXG4gIHJlc29sdmUocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpIHtcbiAgICByZXR1cm4gJy8nICsgcm91dGUudXJsLmpvaW4oJy8nKS5yZXBsYWNlKC9cXC5bXi8uXSskLywgJycpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBSb3V0ZVJldXNlU3RyYXRlZ3ksIERldGFjaGVkUm91dGVIYW5kbGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG4vKipcbiAqIEltcGxlbWVudHMgUm91dGVSZXVzZVN0cmF0ZWd5IHRvIGN1c3RvbWl6ZSByb3V0ZSByZXVzZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEFlbVBhZ2VSb3V0ZVJldXNlU3RyYXRlZ3kgaW1wbGVtZW50cyBSb3V0ZVJldXNlU3RyYXRlZ3kge1xuICAvKiogRGV0ZXJtaW5lcyBpZiB0aGlzIHJvdXRlIChhbmQgaXRzIHN1YnRyZWUpIHNob3VsZCBiZSBkZXRhY2hlZCB0byBiZSByZXVzZWQgbGF0ZXIuICovXG4gIHNob3VsZERldGFjaChyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBOb3Qgc3RvcmluZyBkZXRlYWNoZWQgcm91dGUuICovXG4gIHN0b3JlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBkZXRhY2hlZFRyZWU6IERldGFjaGVkUm91dGVIYW5kbGUpOiB2b2lkIHt9XG5cbiAgLyoqIERldGVybWluZXMgaWYgdGhpcyByb3V0ZSAoYW5kIGl0cyBzdWJ0cmVlKSBzaG91bGQgYmUgcmVhdHRhY2hlZC4gKi9cbiAgc2hvdWxkQXR0YWNoKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIFJldHJpZXZlcyB0aGUgcHJldmlvdXNseSBzdG9yZWQgcm91dGUuICovXG4gIHJldHJpZXZlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogRGV0YWNoZWRSb3V0ZUhhbmRsZSB8IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIERldGVybWluZXMgaWYgYSByb3V0ZSBzaG91bGQgYmUgcmV1c2VkICovXG4gIHNob3VsZFJldXNlUm91dGUoZnV0dXJlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBjdXJyOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiU1BBQ29tcG9uZW50TWFwcGluZyIsIkNvbnN0YW50cyIsIlBNQ29uc3RhbnRzIiwiQ29tcG9uZW50TWFwcGluZyIsIlBMQUNFSE9MREVSX0NMQVNTX05BTUVTIiwidHNsaWJfMS5fX2V4dGVuZHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztB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