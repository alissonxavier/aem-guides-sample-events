import { ComponentMapping } from '@adobe/cq-spa-component-mapping';
import { Constants, ModelManager } from '@adobe/cq-spa-page-model-manager';
import { Directive, Input, Renderer2, NgZone, ViewContainerRef, ComponentFactoryResolver, Component, NgModule, Injectable } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The current class extends the \@adobe/cq-spa-component-mapping#Mapto library and features with Angular specifics such as
 *
 * - Storing the editing configurations for each resource type
 */
class ComponentMappingWithConfig {
    /**
     * @param {?} spaMapping
     */
    constructor(spaMapping) {
        this.spaMapping = spaMapping;
        /**
         * Store of EditConfig structures
         */
        this.editConfigMap = {};
    }
    /**
     * Stores a component class for the given resource types and also allows to provide an EditConfig object
     * @param {?} resourceTypes - List of resource types
     * @param {?} clazz - Component class to be stored
     * @param {?=} editConfig
     * @return {?}
     */
    map(resourceTypes, clazz, editConfig = null) {
        let /** @type {?} */ innerClass = clazz;
        if (editConfig) {
            this.editConfigMap[resourceTypes] = editConfig;
        }
        this.spaMapping.map(resourceTypes, innerClass);
    }
    ;
    /**
     * Returns the component class for the given resourceType
     * @param {?} resourceType - Resource type for which the component class has been stored
     * @return {?}
     */
    get(resourceType) {
        return this.spaMapping.get(resourceType);
    }
    /**
     * Returns the EditConfig structure for the given type
     * @param {?} resourceType - Resource type for which the configuration has been stored
     * @return {?}
     */
    getEditConfig(resourceType) {
        return this.editConfigMap[resourceType];
    }
}
let /** @type {?} */ componentMapping = new ComponentMappingWithConfig(ComponentMapping);
/**
 * @param {?} resourceTypes
 * @return {?}
 */
function MapTo(resourceTypes) {
    return (clazz, editConfig = null) => {
        return componentMapping.map(resourceTypes, clazz, editConfig);
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ Constants$1 = {
    /**
         * Class names associated with a new section component
         *
         */
    NEW_SECTION_CLASS_NAMES: 'new section',
    TYPE_PROP: Constants.TYPE_PROP,
    /**
         * List of child items of an item
         *
         */
    ITEMS_PROP: Constants.ITEMS_PROP,
    /**
         * Order in which the items should be listed
         *
         */
    ITEMS_ORDER_PROP: Constants.ITEMS_ORDER_PROP,
    /**
         * Path of the item
         *
         */
    PATH_PROP: Constants.PATH_PROP,
    /**
         * Children of an item
         *
         */
    CHILDREN_PROP: Constants.CHILDREN_PROP,
    /**
         * Path of the resource in the model
         *
         */
    DATA_PATH_PROP: ':dataPath',
    /**
         * Hierarchical type of the item
         */
    HIERARCHY_TYPE_PROP: Constants.HIERARCHY_TYPE_PROP
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2018 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
/**
 * Selector that identifies the node that contains the WCM mode state
 */
const /** @type {?} */ WCM_MODE_META_SELECTOR = 'meta[property="cq:wcmmode"]';
/**
 * The editor is in one of the edition modes
 */
const /** @type {?} */ EDIT_MODE = 'edit';
/**
 * The editor is in preview mode
 */
const /** @type {?} */ PREVIEW_MODE = 'preview';
/**
 * Returns if we are in the browser context or not by checking for the
 * existence of the window object
 * @return {?}
 */
function isBrowser() {
    try {
        return typeof window !== 'undefined';
    }
    catch (/** @type {?} */ e) {
        return false;
    }
}
/**
 * Returns the current WCM mode
 *
 * <p>Note that the value isn't, as of the date of this writing, updated by the editor</p>
 * @return {?}
 */
function getWCMMode() {
    if (isBrowser()) {
        const /** @type {?} */ wcmModeMeta = document.head.querySelector(WCM_MODE_META_SELECTOR);
        return wcmModeMeta && wcmModeMeta.content;
    }
}
/**
 * Helper functions for interacting with the AEM environment
 */
const /** @type {?} */ Utils = {
    /**
     * Is the app used in the context of the AEM Page editor
     * @return {?}
     */
    isInEditor() {
        const /** @type {?} */ wcmMode = getWCMMode();
        return wcmMode && (EDIT_MODE === wcmMode || PREVIEW_MODE === wcmMode);
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ PLACEHOLDER_CLASS_NAME = 'cq-placeholder';
/**
 * The current directive provides advanced capabilities among which are
 *
 * - The management of the component placeholder in the Page Editor
 * - The dynamic instantiation of components based on a component definition
 * - The conversion from model fields to properties and injection in the component instance
 * - The management of HTMLElement attributes and class names on the native element
 */
class AEMComponentDirective {
    /**
     * @param {?} renderer
     * @param {?} viewContainer
     * @param {?} factoryResolver
     * @param {?} ngZone
     */
    constructor(renderer, viewContainer, factoryResolver, ngZone) {
        this.renderer = renderer;
        this.viewContainer = viewContainer;
        this.factoryResolver = factoryResolver;
        this.ngZone = ngZone;
    }
    /**
     * @return {?}
     */
    get cqItem() {
        return this._cqItem;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set cqItem(value) {
        this._cqItem = value;
        this.updateComponentData();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.renderComponent(componentMapping.get(this.type));
    }
    /**
     * Returns the type of the cqItem if exists.
     * @return {?}
     */
    get type() {
        return this.cqItem && this.cqItem[Constants$1.TYPE_PROP];
    }
    /**
     * Renders a component dynamically based on the component definition
     *
     * @param {?} componentDefinition The component definition to render
     * @return {?}
     */
    renderComponent(componentDefinition) {
        if (componentDefinition) {
            const /** @type {?} */ factory = this.factoryResolver.resolveComponentFactory(componentDefinition);
            this.viewContainer.clear();
            this._component = this.viewContainer.createComponent(factory);
            this.updateComponentData();
        }
    }
    /**
     * Updates the data of the component based the data of the directive
     * @return {?}
     */
    updateComponentData() {
        if (!this._component || !this._component.instance) {
            return;
        }
        let /** @type {?} */ keys = Object.getOwnPropertyNames(this.cqItem);
        keys.forEach((key) => {
            let /** @type {?} */ propKey = key;
            if (propKey.startsWith(":")) {
                // Transformation of internal properties namespaced with [:] to [cq]
                // :myProperty => cqMyProperty
                let /** @type {?} */ tempKey = propKey.substr(1);
                propKey = "cq" + tempKey.substr(0, 1).toUpperCase() + tempKey.substr(1);
            }
            this._component.instance[propKey] = this.cqItem[key];
        });
        this._component.instance.cqPath = this.cqPath;
        this._component.instance.itemName = this.itemName;
        let /** @type {?} */ editConfig = componentMapping.getEditConfig(this.type);
        if (editConfig && Utils.isInEditor) {
            this.setupPlaceholder(editConfig);
        }
    }
    /**
     * Adds the specified item attributes to the element
     * @return {?}
     */
    setupItemAttrs() {
        if (this.itemAttrs) {
            let /** @type {?} */ keys = Object.getOwnPropertyNames(this.itemAttrs);
            keys.forEach((key) => {
                if (key === "class") {
                    let /** @type {?} */ classes = this.itemAttrs[key].split(' ');
                    classes.forEach((itemClass) => {
                        this.renderer.addClass(this._component.location.nativeElement, itemClass);
                    });
                }
                else {
                    this.renderer.setAttribute(this._component.location.nativeElement, key, this.itemAttrs[key]);
                }
            });
        }
    }
    /**
     * Determines if the placeholder should e displayed.
     *
     * @param {?} editConfig - the edit config of the directive
     * @return {?}
     */
    usePlaceholder(editConfig) {
        return editConfig.isEmpty && typeof editConfig.isEmpty === "function" && editConfig.isEmpty(this.cqItem);
    }
    /**
     * Setups the placeholder of needed for the AEM editor
     *
     * @param {?} editConfig - the editConfig, which will dictate the classes to be added on.
     * @return {?}
     */
    setupPlaceholder(editConfig) {
        if (this.usePlaceholder(editConfig)) {
            this.renderer.addClass(this._component.location.nativeElement, PLACEHOLDER_CLASS_NAME);
            this.renderer.setAttribute(this._component.location.nativeElement, "data-emptytext", editConfig.emptyLabel);
        }
        else {
            this.renderer.removeClass(this._component.location.nativeElement, PLACEHOLDER_CLASS_NAME);
            this.renderer.removeAttribute(this._component.location.nativeElement, "data-emptytext");
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setupItemAttrs();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._component && this._component.destroy();
    }
}
AEMComponentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[aemComponent]'
            },] },
];
/** @nocollapse */
AEMComponentDirective.ctorParameters = () => [
    { type: Renderer2, },
    { type: ViewContainerRef, },
    { type: ComponentFactoryResolver, },
    { type: NgZone, },
];
AEMComponentDirective.propDecorators = {
    "cqItem": [{ type: Input },],
    "cqPath": [{ type: Input },],
    "itemName": [{ type: Input },],
    "itemAttrs": [{ type: Input },],
    "aemComponent": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ PLACEHOLDER_CLASS_NAMES = Constants$1.NEW_SECTION_CLASS_NAMES;
const /** @type {?} */ PLACEHOLDER_ITEM_NAME = '*';
const /** @type {?} */ CONTAINER_CLASS_NAMES = 'aem-container';
/**
 * The current component provides the base presentational logic common to containers such as a grid or a page.
 * Container have in common the notion of item holders. Items are represented in the model by the fields _:items_ and _:itemsOrder_
 */
class AEMContainerComponent {
    constructor() {
        /**
         * Path to the model associated with the current instance of the component
         */
        this.cqPath = '';
        /**
         * Key of the model structure
         */
        this.modelName = '';
    }
    /**
     * Returns weather of not we are in the editor
     * @return {?}
     */
    get isInEditMode() {
        return Utils.isInEditor();
    }
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    getDataPath(path) {
        return this.cqPath ? this.cqPath + '/' + path : path;
    }
    /**
     * Returns the item data from the cqModel
     *
     * @param {?} itemKey - the itemKey to look for in the items.
     * @return {?}
     */
    getItem(itemKey) {
        return this.cqItems && this.cqItems[itemKey];
    }
    /**
     * Returns the class names of the container based on the data from the cqModel
     * @return {?}
     */
    getHostClassNames() {
        return CONTAINER_CLASS_NAMES;
    }
    /**
     * @return {?}
     */
    get hostClasses() {
        return this.getHostClassNames();
    }
    /**
     * Returns the placeholder classes
     * @return {?}
     */
    getPlaceholderClassNames() {
        return PLACEHOLDER_CLASS_NAMES;
    }
    /**
     * Returns the placeholder path
     * @return {?}
     */
    get placeholderPath() {
        return this.cqPath && this.cqPath + '/' + PLACEHOLDER_ITEM_NAME;
    }
}
AEMContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'aem-container',
                host: {
                    '[class]': 'hostClasses',
                    '[attr.data-cq-data-path]': 'cqPath'
                },
                template: `<ng-container *ngFor="let itemKey of cqItemsOrder">
  <ng-container [aemComponent] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey'></ng-container>
  <div *ngIf="isInEditMode" [attr.data-cq-data-path]="placeholderPath" [class]="getPlaceholderClassNames()"></div>
</ng-container>
`
            },] },
];
/** @nocollapse */
AEMContainerComponent.propDecorators = {
    "cqItems": [{ type: Input },],
    "cqItemsOrder": [{ type: Input },],
    "cqPath": [{ type: Input },],
    "modelName": [{ type: Input },],
    "classNames": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ PLACEHOLDER_CLASS_NAMES$1 = ' aem-Grid-newComponent';
const /** @type {?} */ RESPONSIVE_GRID_TYPE = 'wcm/foundation/components/responsivegrid';
/**
 * The current class carries the base presentational logic of the AEM Layout Container (aka. Responsive grid)
 */
class AEMResponsiveGridComponent extends AEMContainerComponent {
    /**
     * Returns the column class names for a given column
     * @param {?} itemKey - The key of the column item
     * @return {?}
     */
    getColumnClassNames(itemKey) {
        return this.columnClassNames && this.columnClassNames[itemKey];
    }
    /**
     * Returns the placeholder classes
     * @return {?}
     */
    getPlaceholderClassNames() {
        return super.getPlaceholderClassNames() + PLACEHOLDER_CLASS_NAMES$1;
    }
    /**
     * Returns the class names of the responsive grid based on the data from the cqModel
     * @return {?}
     */
    getHostClassNames() {
        let /** @type {?} */ classNames = super.getHostClassNames();
        if (this.classNames) {
            classNames += ' ' + (this.classNames || '');
        }
        return classNames + ' ' + this.gridClassNames;
    }
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    getAttrDataPath(path) {
        let /** @type {?} */ item = this.getItem(path);
        if (item && item[Constants$1.TYPE_PROP] === RESPONSIVE_GRID_TYPE) {
            // We don't want to add the path for the wrapper for a reponsivegrid
            // The reponsivegrid adds the path on it's own
            return null;
        }
        return this.getDataPath(path);
    }
}
AEMResponsiveGridComponent.decorators = [
    { type: Component, args: [{
                selector: 'aem-responsivegrid',
                host: {
                    '[class]': 'hostClasses',
                    '[attr.data-cq-data-path]': 'cqPath'
                },
                template: `<ng-container *ngFor="let itemKey of cqItemsOrder">
  <div [aemModelProvider] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey' [class]="getColumnClassNames(itemKey)" [attr.data-cq-data-path]='getAttrDataPath(itemKey)'>
  </div>
</ng-container>
<div *ngIf="isInEditMode" [attr.data-cq-data-path]="placeholderPath" [class]="getPlaceholderClassNames()"></div>


`,
            },] },
];
/** @nocollapse */
AEMResponsiveGridComponent.propDecorators = {
    "gridClassNames": [{ type: Input },],
    "columnClassNames": [{ type: Input },],
    "classNames": [{ type: Input },],
    "columnCount": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The current component is responsible for providing access to the ModelManager and the model of a component
 */
class AEMModelProviderComponent {
    /**
     * @param {?} ngZone
     */
    constructor(ngZone) {
        this.ngZone = ngZone;
    }
    /**
     * Updates the item data
     * @return {?}
     */
    updateItem() {
        ModelManager.getData({ path: this.cqPath }).then(model => {
            this.ngZone.run(() => {
                this.cqItem = model;
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        ModelManager.addListener(this.cqPath, this.updateItem.bind(this));
    }
    /**
     * @return {?}
     */
    ngDestroy() {
        ModelManager.removeListener(this.cqPath, this.updateItem.bind(this));
    }
}
AEMModelProviderComponent.decorators = [
    { type: Component, args: [{
                selector: '[aemModelProvider]',
                template: `<ng-container [aemComponent] [cqItem]='cqItem' [cqPath]='cqPath' [itemName]='itemName'></ng-container>`
            },] },
];
/** @nocollapse */
AEMModelProviderComponent.ctorParameters = () => [
    { type: NgZone, },
];
AEMModelProviderComponent.propDecorators = {
    "cqPath": [{ type: Input },],
    "cqItem": [{ type: Input },],
    "itemName": [{ type: Input },],
    "aemModelProvider": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ PAGE_MODEL_SEPARATOR = '/jcr:content/';
/**
 * The current component carries the base presentational logic of page component
 */
class AEMPageComponent extends AEMContainerComponent {
    /**
     * Returns the aggregated path of this container path and the provided path
     *
     * @param {?} path - the provided path to aggregate with the container path
     * @return {?}
     */
    getDataPath(path) {
        return this.cqPath ? this.cqPath + PAGE_MODEL_SEPARATOR + path : path;
    }
}
AEMPageComponent.decorators = [
    { type: Component, args: [{
                selector: 'aem-page',
                host: {
                    '[class]': 'hostClasses',
                    '[attr.data-cq-data-path]': 'cqPath'
                },
                template: `<ng-container *ngFor="let itemKey of cqItemsOrder">
  <ng-container [aemComponent] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey'></ng-container>
  <div *ngIf="isInEditMode" [attr.data-cq-data-path]="placeholderPath" [class]="getPlaceholderClassNames()"></div>
</ng-container>
`
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SpaAngularEditableComponentsModule {
}
SpaAngularEditableComponentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [AEMContainerComponent, AEMResponsiveGridComponent, AEMComponentDirective, AEMModelProviderComponent, AEMPageComponent],
                exports: [AEMContainerComponent, AEMResponsiveGridComponent, AEMComponentDirective, AEMModelProviderComponent, AEMPageComponent],
                entryComponents: [AEMContainerComponent, AEMResponsiveGridComponent, AEMPageComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AemPageDataResolver {
    constructor() { }
    /**
     * Returns the absolute resource path without extension.
     * \@example
     * // returns: '/content/aa/bb' for route.url [ 'content', 'aa', 'bb.html' ]
     * resolve(route)
     * @param {?} route - route
     * @return {?} absolute resource path without extension
     */
    resolve(route) {
        return '/' + route.url.join('/').replace(/\.[^/.]+$/, '');
    }
}
AemPageDataResolver.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AemPageDataResolver.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Implements RouteReuseStrategy to customize route reuse.
 */
class AemPageRouteReuseStrategy {
    /**
     * Determines if this route (and its subtree) should be detached to be reused later.
     * @param {?} route
     * @return {?}
     */
    shouldDetach(route) {
        return false;
    }
    /**
     * Not storing deteached route.
     * @param {?} route
     * @param {?} detachedTree
     * @return {?}
     */
    store(route, detachedTree) { }
    /**
     * Determines if this route (and its subtree) should be reattached.
     * @param {?} route
     * @return {?}
     */
    shouldAttach(route) {
        return false;
    }
    /**
     * Retrieves the previously stored route.
     * @param {?} route
     * @return {?}
     */
    retrieve(route) {
        return null;
    }
    /**
     * Determines if a route should be reused
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    shouldReuseRoute(future, curr) {
        return false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { AEMComponentDirective, AEMContainerComponent, AEMResponsiveGridComponent, ComponentMappingWithConfig, componentMapping as ComponentMapping, MapTo, Constants$1 as Constants, Utils, SpaAngularEditableComponentsModule, AemPageDataResolver, AemPageRouteReuseStrategy, AEMModelProviderComponent as ɵa, AEMPageComponent as ɵb };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRvYmUtY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvY29tcG9uZW50LW1hcHBpbmcudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2xheW91dC9jb25zdGFudHMudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2xheW91dC91dGlscy50cyIsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvbGF5b3V0L2FlbS1jb21wb25lbnQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvYWVtLWNvbnRhaW5lci9hZW0tY29udGFpbmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvbGF5b3V0L2FlbS1yZXNwb25zaXZlZ3JpZC9hZW0tcmVzcG9uc2l2ZWdyaWQuY29tcG9uZW50LnRzIiwibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvYWVtLW1vZGVsLXByb3ZpZGVyL2FlbS1tb2RlbC1wcm92aWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2xheW91dC9hZW0tcGFnZS9hZW0tcGFnZS5jb21wb25lbnQudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy5tb2R1bGUudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL3JvdXRpbmcvQWVtUGFnZURhdGFSZXNvbHZlci50cyIsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvcm91dGluZy9BZW1QYWdlUm91dGVSZXVzZVN0cmF0ZWd5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnRNYXBwaW5nIGFzIFNQQUNvbXBvbmVudE1hcHBpbmcgfSBmcm9tICdAYWRvYmUvY3Etc3BhLWNvbXBvbmVudC1tYXBwaW5nJztcblxuLyoqXG4gKiBUaGUgY3VycmVudCBjbGFzcyBleHRlbmRzIHRoZSBAYWRvYmUvY3Etc3BhLWNvbXBvbmVudC1tYXBwaW5nI01hcHRvIGxpYnJhcnkgYW5kIGZlYXR1cmVzIHdpdGggQW5ndWxhciBzcGVjaWZpY3Mgc3VjaCBhc1xuICpcbiAqIC0gU3RvcmluZyB0aGUgZWRpdGluZyBjb25maWd1cmF0aW9ucyBmb3IgZWFjaCByZXNvdXJjZSB0eXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRNYXBwaW5nV2l0aENvbmZpZyB7XG4gIC8qKlxuICAgKiBTdG9yZSBvZiBFZGl0Q29uZmlnIHN0cnVjdHVyZXNcbiAgICovXG4gIHByaXZhdGUgZWRpdENvbmZpZ01hcCA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3BhTWFwcGluZzpTUEFDb21wb25lbnRNYXBwaW5nKSB7fVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBjb21wb25lbnQgY2xhc3MgZm9yIHRoZSBnaXZlbiByZXNvdXJjZSB0eXBlcyBhbmQgYWxzbyBhbGxvd3MgdG8gcHJvdmlkZSBhbiBFZGl0Q29uZmlnIG9iamVjdFxuICAgKiBAcGFyYW0gcmVzb3VyY2VUeXBlcyAtIExpc3Qgb2YgcmVzb3VyY2UgdHlwZXNcbiAgICogQHBhcmFtIGNsYXp6IC0gQ29tcG9uZW50IGNsYXNzIHRvIGJlIHN0b3JlZFxuICAgKiBAcGFyYW0gW2VkaXRDb25maWddIC0gRWRpdCBjb25maWd1cmF0aW9uIHRvIGJlIHN0b3JlZCBmb3IgdGhlIGdpdmVuIHJlc291cmNlIHR5cGVzXG4gICAqL1xuICBtYXAocmVzb3VyY2VUeXBlcywgY2xhenosIGVkaXRDb25maWcgPSBudWxsKSB7XG4gICAgICBsZXQgaW5uZXJDbGFzcyA9IGNsYXp6O1xuXG4gICAgICBpZiAoZWRpdENvbmZpZykge1xuICAgICAgICAgIHRoaXMuZWRpdENvbmZpZ01hcFtyZXNvdXJjZVR5cGVzXSA9IGVkaXRDb25maWc7XG4gICAgICB9XG4gICAgICB0aGlzLnNwYU1hcHBpbmcubWFwKHJlc291cmNlVHlwZXMsIGlubmVyQ2xhc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgY2xhc3MgZm9yIHRoZSBnaXZlbiByZXNvdXJjZVR5cGVcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZSAtIFJlc291cmNlIHR5cGUgZm9yIHdoaWNoIHRoZSBjb21wb25lbnQgY2xhc3MgaGFzIGJlZW4gc3RvcmVkXG4gICAqL1xuICBnZXQocmVzb3VyY2VUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BhTWFwcGluZy5nZXQocmVzb3VyY2VUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBFZGl0Q29uZmlnIHN0cnVjdHVyZSBmb3IgdGhlIGdpdmVuIHR5cGVcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZSAtIFJlc291cmNlIHR5cGUgZm9yIHdoaWNoIHRoZSBjb25maWd1cmF0aW9uIGhhcyBiZWVuIHN0b3JlZFxuICAgKi9cbiAgZ2V0RWRpdENvbmZpZyhyZXNvdXJjZVR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0Q29uZmlnTWFwW3Jlc291cmNlVHlwZV07XG4gIH1cbn1cblxubGV0IGNvbXBvbmVudE1hcHBpbmcgPSBuZXcgQ29tcG9uZW50TWFwcGluZ1dpdGhDb25maWcoU1BBQ29tcG9uZW50TWFwcGluZyk7XG5cbmZ1bmN0aW9uIE1hcFRvKHJlc291cmNlVHlwZXMpIHtcbiAgICByZXR1cm4gKGNsYXp6LCBlZGl0Q29uZmlnID0gbnVsbCkgPT4ge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50TWFwcGluZy5tYXAocmVzb3VyY2VUeXBlcywgY2xhenosIGVkaXRDb25maWcpO1xuICAgIH07XG59XG5cblxuZXhwb3J0IHsgY29tcG9uZW50TWFwcGluZyBhcyBDb21wb25lbnRNYXBwaW5nLCBNYXBUbyB9O1xuIiwiLypcbiAqIEFET0JFIENPTkZJREVOVElBTFxuICpcbiAqIENvcHlyaWdodCAyMDE4IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVElDRTogIEFsbCBpbmZvcm1hdGlvbiBjb250YWluZWQgaGVyZWluIGlzLCBhbmQgcmVtYWluc1xuICogdGhlIHByb3BlcnR5IG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHMgc3VwcGxpZXJzLFxuICogaWYgYW55LiAgVGhlIGludGVsbGVjdHVhbCBhbmQgdGVjaG5pY2FsIGNvbmNlcHRzIGNvbnRhaW5lZFxuICogaGVyZWluIGFyZSBwcm9wcmlldGFyeSB0byBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzXG4gKiBzdXBwbGllcnMgYW5kIG1heSBiZSBjb3ZlcmVkIGJ5IFUuUy4gYW5kIEZvcmVpZ24gUGF0ZW50cyxcbiAqIHBhdGVudHMgaW4gcHJvY2VzcywgYW5kIGFyZSBwcm90ZWN0ZWQgYnkgdHJhZGUgc2VjcmV0IG9yIGNvcHlyaWdodCBsYXcuXG4gKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcbiAqIGlzIHN0cmljdGx5IGZvcmJpZGRlbiB1bmxlc3MgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uIGlzIG9idGFpbmVkXG4gKiBmcm9tIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLlxuICovXG5cbmltcG9ydCB7Q29uc3RhbnRzIGFzIFBNQ29uc3RhbnRzfSBmcm9tICdAYWRvYmUvY3Etc3BhLXBhZ2UtbW9kZWwtbWFuYWdlcic7XG5cbmV4cG9ydCBjb25zdCBDb25zdGFudHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBuYW1lcyBhc3NvY2lhdGVkIHdpdGggYSBuZXcgc2VjdGlvbiBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIE5FV19TRUNUSU9OX0NMQVNTX05BTUVTOiAnbmV3IHNlY3Rpb24nLFxuXG4gICAgVFlQRV9QUk9QOiBQTUNvbnN0YW50cy5UWVBFX1BST1AsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGNoaWxkIGl0ZW1zIG9mIGFuIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIElURU1TX1BST1A6IFBNQ29uc3RhbnRzLklURU1TX1BST1AsXG5cbiAgICAvKipcbiAgICAgKiBPcmRlciBpbiB3aGljaCB0aGUgaXRlbXMgc2hvdWxkIGJlIGxpc3RlZFxuICAgICAqXG4gICAgICovXG4gICAgSVRFTVNfT1JERVJfUFJPUDogUE1Db25zdGFudHMuSVRFTVNfT1JERVJfUFJPUCxcblxuICAgIC8qKlxuICAgICAqIFBhdGggb2YgdGhlIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIFBBVEhfUFJPUDogUE1Db25zdGFudHMuUEFUSF9QUk9QLFxuXG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gb2YgYW4gaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgQ0hJTERSRU5fUFJPUDogUE1Db25zdGFudHMuQ0hJTERSRU5fUFJPUCxcblxuICAgIC8qKlxuICAgICAqIFBhdGggb2YgdGhlIHJlc291cmNlIGluIHRoZSBtb2RlbFxuICAgICAqXG4gICAgICovXG4gICAgREFUQV9QQVRIX1BST1A6ICc6ZGF0YVBhdGgnLFxuXG4gICAgLyoqXG4gICAgICogSGllcmFyY2hpY2FsIHR5cGUgb2YgdGhlIGl0ZW1cbiAgICAgKi9cbiAgICBISUVSQVJDSFlfVFlQRV9QUk9QOiBQTUNvbnN0YW50cy5ISUVSQVJDSFlfVFlQRV9QUk9QXG59O1xuIiwiLypcbiAqIEFET0JFIENPTkZJREVOVElBTFxuICpcbiAqIENvcHlyaWdodCAyMDE4IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVElDRTogIEFsbCBpbmZvcm1hdGlvbiBjb250YWluZWQgaGVyZWluIGlzLCBhbmQgcmVtYWluc1xuICogdGhlIHByb3BlcnR5IG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHMgc3VwcGxpZXJzLFxuICogaWYgYW55LiAgVGhlIGludGVsbGVjdHVhbCBhbmQgdGVjaG5pY2FsIGNvbmNlcHRzIGNvbnRhaW5lZFxuICogaGVyZWluIGFyZSBwcm9wcmlldGFyeSB0byBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzXG4gKiBzdXBwbGllcnMgYW5kIG1heSBiZSBjb3ZlcmVkIGJ5IFUuUy4gYW5kIEZvcmVpZ24gUGF0ZW50cyxcbiAqIHBhdGVudHMgaW4gcHJvY2VzcywgYW5kIGFyZSBwcm90ZWN0ZWQgYnkgdHJhZGUgc2VjcmV0IG9yIGNvcHlyaWdodCBsYXcuXG4gKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcbiAqIGlzIHN0cmljdGx5IGZvcmJpZGRlbiB1bmxlc3MgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uIGlzIG9idGFpbmVkXG4gKiBmcm9tIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLlxuICovXG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCBpZGVudGlmaWVzIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIFdDTSBtb2RlIHN0YXRlXG4gKi9cbmNvbnN0IFdDTV9NT0RFX01FVEFfU0VMRUNUT1I6c3RyaW5nID0gJ21ldGFbcHJvcGVydHk9XCJjcTp3Y21tb2RlXCJdJztcblxuLyoqXG4gKiBUaGUgZWRpdG9yIGlzIGluIG9uZSBvZiB0aGUgZWRpdGlvbiBtb2Rlc1xuICovXG5jb25zdCBFRElUX01PREU6c3RyaW5nID0gJ2VkaXQnO1xuXG4vKipcbiAqIFRoZSBlZGl0b3IgaXMgaW4gcHJldmlldyBtb2RlXG4gKi9cbmNvbnN0IFBSRVZJRVdfTU9ERTpzdHJpbmcgPSAncHJldmlldyc7XG4vKipcbiAqIFJldHVybnMgaWYgd2UgYXJlIGluIHRoZSBicm93c2VyIGNvbnRleHQgb3Igbm90IGJ5IGNoZWNraW5nIGZvciB0aGVcbiAqIGV4aXN0ZW5jZSBvZiB0aGUgd2luZG93IG9iamVjdFxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IFdDTSBtb2RlXG4gKlxuICogPHA+Tm90ZSB0aGF0IHRoZSB2YWx1ZSBpc24ndCwgYXMgb2YgdGhlIGRhdGUgb2YgdGhpcyB3cml0aW5nLCB1cGRhdGVkIGJ5IHRoZSBlZGl0b3I8L3A+XG4gKi9cbmZ1bmN0aW9uIGdldFdDTU1vZGUoKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICBjb25zdCB3Y21Nb2RlTWV0YTphbnkgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoV0NNX01PREVfTUVUQV9TRUxFQ1RPUik7XG4gICAgICByZXR1cm4gd2NtTW9kZU1ldGEgJiYgd2NtTW9kZU1ldGEuY29udGVudDtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgQUVNIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBVdGlscyA9IHtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBhcHAgdXNlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgQUVNIFBhZ2UgZWRpdG9yXG4gICAgICovXG4gICAgaXNJbkVkaXRvcigpIHtcbiAgICAgICAgY29uc3Qgd2NtTW9kZSA9IGdldFdDTU1vZGUoKTtcbiAgICAgICAgcmV0dXJuIHdjbU1vZGUgJiYgKEVESVRfTU9ERSA9PT0gd2NtTW9kZSB8fCBQUkVWSUVXX01PREUgPT09IHdjbU1vZGUpO1xuICAgIH1cbn07XG4iLCIvKlxuICogQURPQkUgQ09ORklERU5USUFMXG4gKlxuICogQ29weXJpZ2h0IDIwMTggQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWRcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTk9USUNFOiAgQWxsIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBoZXJlaW4gaXMsIGFuZCByZW1haW5zXG4gKiB0aGUgcHJvcGVydHkgb2YgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0cyBzdXBwbGllcnMsXG4gKiBpZiBhbnkuICBUaGUgaW50ZWxsZWN0dWFsIGFuZCB0ZWNobmljYWwgY29uY2VwdHMgY29udGFpbmVkXG4gKiBoZXJlaW4gYXJlIHByb3ByaWV0YXJ5IHRvIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHNcbiAqIHN1cHBsaWVycyBhbmQgbWF5IGJlIGNvdmVyZWQgYnkgVS5TLiBhbmQgRm9yZWlnbiBQYXRlbnRzLFxuICogcGF0ZW50cyBpbiBwcm9jZXNzLCBhbmQgYXJlIHByb3RlY3RlZCBieSB0cmFkZSBzZWNyZXQgb3IgY29weXJpZ2h0IGxhdy5cbiAqIERpc3NlbWluYXRpb24gb2YgdGhpcyBpbmZvcm1hdGlvbiBvciByZXByb2R1Y3Rpb24gb2YgdGhpcyBtYXRlcmlhbFxuICogaXMgc3RyaWN0bHkgZm9yYmlkZGVuIHVubGVzcyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24gaXMgb2J0YWluZWRcbiAqIGZyb20gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgUmVuZGVyZXIyLCBOZ1pvbmUsIFZpZXdDb250YWluZXJSZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENvbXBvbmVudE1hcHBpbmcgfSBmcm9tICcuL2NvbXBvbmVudC1tYXBwaW5nJztcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5cblxuY29uc3QgUExBQ0VIT0xERVJfQ0xBU1NfTkFNRSA9ICdjcS1wbGFjZWhvbGRlcic7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1thZW1Db21wb25lbnRdJ1xufSlcblxuLyoqXG4gKiBUaGUgY3VycmVudCBkaXJlY3RpdmUgcHJvdmlkZXMgYWR2YW5jZWQgY2FwYWJpbGl0aWVzIGFtb25nIHdoaWNoIGFyZVxuICpcbiAqIC0gVGhlIG1hbmFnZW1lbnQgb2YgdGhlIGNvbXBvbmVudCBwbGFjZWhvbGRlciBpbiB0aGUgUGFnZSBFZGl0b3JcbiAqIC0gVGhlIGR5bmFtaWMgaW5zdGFudGlhdGlvbiBvZiBjb21wb25lbnRzIGJhc2VkIG9uIGEgY29tcG9uZW50IGRlZmluaXRpb25cbiAqIC0gVGhlIGNvbnZlcnNpb24gZnJvbSBtb2RlbCBmaWVsZHMgdG8gcHJvcGVydGllcyBhbmQgaW5qZWN0aW9uIGluIHRoZSBjb21wb25lbnQgaW5zdGFuY2VcbiAqIC0gVGhlIG1hbmFnZW1lbnQgb2YgSFRNTEVsZW1lbnQgYXR0cmlidXRlcyBhbmQgY2xhc3MgbmFtZXMgb24gdGhlIG5hdGl2ZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBBRU1Db21wb25lbnREaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgLyoqXG4gICAqIER5bmFtaWNhbGx5IGNyZWF0ZWQgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIF9jb21wb25lbnQ6Q29tcG9uZW50UmVmPGFueT47XG4gIC8qKlxuICAgKiBNb2RlbCBpdGVtIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIF9jcUl0ZW06b2JqZWN0O1xuXG4gIGdldCBjcUl0ZW0oKTogb2JqZWN0IHtcbiAgICByZXR1cm4gdGhpcy5fY3FJdGVtO1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IGNxSXRlbSh2YWx1ZTogb2JqZWN0KSB7XG4gICAgdGhpcy5fY3FJdGVtID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnREYXRhKCk7XG4gIH1cblxuICAvKipcbiAgICogUGF0aCB0byB0aGUgbW9kZWwgc3RydWN0dXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGNxUGF0aDpzdHJpbmc7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGl0ZW1OYW1lOnN0cmluZztcbiAgLyoqXG4gICAqIEh0bWxFbGVtZW50IGF0dHJpYnV0ZXMgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGl0ZW1BdHRyczogb2JqZWN0O1xuXG4gIEBJbnB1dCgpIGFlbUNvbXBvbmVudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgZmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5yZW5kZXJDb21wb25lbnQoQ29tcG9uZW50TWFwcGluZy5nZXQodGhpcy50eXBlKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgY3FJdGVtIGlmIGV4aXN0cy5cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNxSXRlbSAmJiB0aGlzLmNxSXRlbVtDb25zdGFudHMuVFlQRV9QUk9QXTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBhIGNvbXBvbmVudCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb25cbiAgICpcbiAgICogQHBhcmFtIGNvbXBvbmVudERlZmluaXRpb24gVGhlIGNvbXBvbmVudCBkZWZpbml0aW9uIHRvIHJlbmRlclxuICAgKi9cbiAgcHJpdmF0ZSByZW5kZXJDb21wb25lbnQoY29tcG9uZW50RGVmaW5pdGlvbjphbnkpIHtcbiAgICBpZiAoY29tcG9uZW50RGVmaW5pdGlvbikge1xuICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudERlZmluaXRpb24pO1xuICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB0aGlzLl9jb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnREYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRhdGEgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB0aGUgZGF0YSBvZiB0aGUgZGlyZWN0aXZlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUNvbXBvbmVudERhdGEoKSB7XG4gICAgaWYgKCF0aGlzLl9jb21wb25lbnQgfHwgIXRoaXMuX2NvbXBvbmVudC5pbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5jcUl0ZW0pO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHByb3BLZXkgPSBrZXk7XG5cbiAgICAgICAgaWYgKHByb3BLZXkuc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybWF0aW9uIG9mIGludGVybmFsIHByb3BlcnRpZXMgbmFtZXNwYWNlZCB3aXRoIFs6XSB0byBbY3FdXG4gICAgICAgICAgICAvLyA6bXlQcm9wZXJ0eSA9PiBjcU15UHJvcGVydHlcbiAgICAgICAgICAgIGxldCB0ZW1wS2V5ID0gcHJvcEtleS5zdWJzdHIoMSk7XG4gICAgICAgICAgICBwcm9wS2V5ID0gXCJjcVwiICsgdGVtcEtleS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHRlbXBLZXkuc3Vic3RyKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29tcG9uZW50Lmluc3RhbmNlW3Byb3BLZXldID0gdGhpcy5jcUl0ZW1ba2V5XTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NvbXBvbmVudC5pbnN0YW5jZS5jcVBhdGggPSB0aGlzLmNxUGF0aDtcbiAgICB0aGlzLl9jb21wb25lbnQuaW5zdGFuY2UuaXRlbU5hbWUgPSB0aGlzLml0ZW1OYW1lO1xuICAgIGxldCBlZGl0Q29uZmlnID0gQ29tcG9uZW50TWFwcGluZy5nZXRFZGl0Q29uZmlnKHRoaXMudHlwZSk7XG4gICAgaWYgKGVkaXRDb25maWcgJiYgVXRpbHMuaXNJbkVkaXRvcikge1xuICAgICAgdGhpcy5zZXR1cFBsYWNlaG9sZGVyKGVkaXRDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgaXRlbSBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIHNldHVwSXRlbUF0dHJzKCkge1xuICAgIGlmICh0aGlzLml0ZW1BdHRycykge1xuICAgICAgbGV0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLml0ZW1BdHRycyk7XG5cbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgIGxldCBjbGFzc2VzID0gdGhpcy5pdGVtQXR0cnNba2V5XS5zcGxpdCgnICcpO1xuICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaCgoaXRlbUNsYXNzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBpdGVtQ2xhc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBrZXkgLCB0aGlzLml0ZW1BdHRyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBlIGRpc3BsYXllZC5cbiAgICpcbiAgICogQHBhcmFtIGVkaXRDb25maWcgLSB0aGUgZWRpdCBjb25maWcgb2YgdGhlIGRpcmVjdGl2ZVxuICAgKi9cbiAgcHJpdmF0ZSB1c2VQbGFjZWhvbGRlcihlZGl0Q29uZmlnKSB7XG4gICAgcmV0dXJuIGVkaXRDb25maWcuaXNFbXB0eSAmJiB0eXBlb2YgZWRpdENvbmZpZy5pc0VtcHR5ID09PSBcImZ1bmN0aW9uXCIgJiYgZWRpdENvbmZpZy5pc0VtcHR5KHRoaXMuY3FJdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cHMgdGhlIHBsYWNlaG9sZGVyIG9mIG5lZWRlZCBmb3IgdGhlIEFFTSBlZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIGVkaXRDb25maWcgLSB0aGUgZWRpdENvbmZpZywgd2hpY2ggd2lsbCBkaWN0YXRlIHRoZSBjbGFzc2VzIHRvIGJlIGFkZGVkIG9uLlxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cFBsYWNlaG9sZGVyKGVkaXRDb25maWcpIHtcbiAgICBpZiAodGhpcy51c2VQbGFjZWhvbGRlcihlZGl0Q29uZmlnKSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBQTEFDRUhPTERFUl9DTEFTU19OQU1FKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIFwiZGF0YS1lbXB0eXRleHRcIiwgZWRpdENvbmZpZy5lbXB0eUxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBQTEFDRUhPTERFUl9DTEFTU19OQU1FKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5fY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIFwiZGF0YS1lbXB0eXRleHRcIik7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuc2V0dXBJdGVtQXR0cnMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2NvbXBvbmVudCAmJiB0aGlzLl9jb21wb25lbnQuZGVzdHJveSgpO1xuICB9XG5cbn1cbiIsIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gXCIuLi91dGlsc1wiO1xuXG5jb25zdCBQTEFDRUhPTERFUl9DTEFTU19OQU1FUyA9IENvbnN0YW50cy5ORVdfU0VDVElPTl9DTEFTU19OQU1FUztcbmNvbnN0IFBMQUNFSE9MREVSX0lURU1fTkFNRSA9ICcqJztcbmNvbnN0IENPTlRBSU5FUl9DTEFTU19OQU1FUyA9ICdhZW0tY29udGFpbmVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYWVtLWNvbnRhaW5lcicsXG4gIGhvc3Q6IHtcbiAgICAgICdbY2xhc3NdJzogJ2hvc3RDbGFzc2VzJyxcbiAgICAgICdbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF0nOidjcVBhdGgnXG4gIH0sXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbUtleSBvZiBjcUl0ZW1zT3JkZXJcIj5cbiAgPG5nLWNvbnRhaW5lciBbYWVtQ29tcG9uZW50XSBbY3FJdGVtXT0nZ2V0SXRlbShpdGVtS2V5KScgW2NxUGF0aF09J2dldERhdGFQYXRoKGl0ZW1LZXkpJyBbaXRlbU5hbWVdPSdpdGVtS2V5Jz48L25nLWNvbnRhaW5lcj5cbiAgPGRpdiAqbmdJZj1cImlzSW5FZGl0TW9kZVwiIFthdHRyLmRhdGEtY3EtZGF0YS1wYXRoXT1cInBsYWNlaG9sZGVyUGF0aFwiIFtjbGFzc109XCJnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKVwiPjwvZGl2PlxuPC9uZy1jb250YWluZXI+XG5gXG59KVxuLyoqXG4gKiBUaGUgY3VycmVudCBjb21wb25lbnQgcHJvdmlkZXMgdGhlIGJhc2UgcHJlc2VudGF0aW9uYWwgbG9naWMgY29tbW9uIHRvIGNvbnRhaW5lcnMgc3VjaCBhcyBhIGdyaWQgb3IgYSBwYWdlLlxuICogQ29udGFpbmVyIGhhdmUgaW4gY29tbW9uIHRoZSBub3Rpb24gb2YgaXRlbSBob2xkZXJzLiBJdGVtcyBhcmUgcmVwcmVzZW50ZWQgaW4gdGhlIG1vZGVsIGJ5IHRoZSBmaWVsZHMgXzppdGVtc18gYW5kIF86aXRlbXNPcmRlcl9cbiAqL1xuZXhwb3J0IGNsYXNzIEFFTUNvbnRhaW5lckNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBNYXAgb2YgbW9kZWwgaXRlbXMgaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgY29udGFpbmVyXG4gICAqL1xuICBASW5wdXQoKSBjcUl0ZW1zO1xuICAvKipcbiAgICogQXJyYXkgb2YgbW9kZWwgaXRlbSBrZXlzXG4gICAqL1xuICBASW5wdXQoKSBjcUl0ZW1zT3JkZXI7XG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY3FQYXRoOnN0cmluZyA9ICcnO1xuICAvKipcbiAgICogS2V5IG9mIHRoZSBtb2RlbCBzdHJ1Y3R1cmVcbiAgICovXG4gIEBJbnB1dCgpIG1vZGVsTmFtZTpzdHJpbmcgPSAnJztcbiAgLyoqXG4gICAqIENsYXNzIG5hbWVzIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY2xhc3NOYW1lczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdlYXRoZXIgb2Ygbm90IHdlIGFyZSBpbiB0aGUgZWRpdG9yXG4gICAqL1xuICBnZXQgaXNJbkVkaXRNb2RlKCkge1xuICAgIHJldHVybiBVdGlscy5pc0luRWRpdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWdncmVnYXRlZCBwYXRoIG9mIHRoaXMgY29udGFpbmVyIHBhdGggYW5kIHRoZSBwcm92aWRlZCBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIC0gdGhlIHByb3ZpZGVkIHBhdGggdG8gYWdncmVnYXRlIHdpdGggdGhlIGNvbnRhaW5lciBwYXRoXG4gICAqL1xuICBnZXREYXRhUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3FQYXRoID8gdGhpcy5jcVBhdGggKyAnLycgKyBwYXRoIDogcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVtIGRhdGEgZnJvbSB0aGUgY3FNb2RlbFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbUtleSAtIHRoZSBpdGVtS2V5IHRvIGxvb2sgZm9yIGluIHRoZSBpdGVtcy5cbiAgICovXG4gIGdldEl0ZW0oaXRlbUtleSkge1xuICAgIHJldHVybiB0aGlzLmNxSXRlbXMgJiYgdGhpcy5jcUl0ZW1zW2l0ZW1LZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWVzIG9mIHRoZSBjb250YWluZXIgYmFzZWQgb24gdGhlIGRhdGEgZnJvbSB0aGUgY3FNb2RlbFxuICAgKi9cbiAgZ2V0SG9zdENsYXNzTmFtZXMoKSB7XG4gICAgcmV0dXJuIENPTlRBSU5FUl9DTEFTU19OQU1FUztcbiAgfVxuXG4gIGdldCBob3N0Q2xhc3NlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SG9zdENsYXNzTmFtZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjbGFzc2VzXG4gICAqL1xuICBnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKSB7XG4gICAgcmV0dXJuIFBMQUNFSE9MREVSX0NMQVNTX05BTUVTO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHBhdGhcbiAgICovXG4gIGdldCBwbGFjZWhvbGRlclBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3FQYXRoICYmIHRoaXMuY3FQYXRoICsgJy8nICsgUExBQ0VIT0xERVJfSVRFTV9OQU1FO1xuICB9XG59XG5cbiIsIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBRU1Db250YWluZXJDb21wb25lbnQgfSBmcm9tICcuLi9hZW0tY29udGFpbmVyL2FlbS1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmNvbnN0IFBMQUNFSE9MREVSX0NMQVNTX05BTUVTID0gJyBhZW0tR3JpZC1uZXdDb21wb25lbnQnO1xuY29uc3QgUkVTUE9OU0lWRV9HUklEX1RZUEUgPSAnd2NtL2ZvdW5kYXRpb24vY29tcG9uZW50cy9yZXNwb25zaXZlZ3JpZCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2FlbS1yZXNwb25zaXZlZ3JpZCcsXG4gIGhvc3Q6IHtcbiAgICAgICdbY2xhc3NdJzogJ2hvc3RDbGFzc2VzJyxcbiAgICAgICdbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF0nOidjcVBhdGgnXG4gIH0sXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbUtleSBvZiBjcUl0ZW1zT3JkZXJcIj5cbiAgPGRpdiBbYWVtTW9kZWxQcm92aWRlcl0gW2NxSXRlbV09J2dldEl0ZW0oaXRlbUtleSknIFtjcVBhdGhdPSdnZXREYXRhUGF0aChpdGVtS2V5KScgW2l0ZW1OYW1lXT0naXRlbUtleScgW2NsYXNzXT1cImdldENvbHVtbkNsYXNzTmFtZXMoaXRlbUtleSlcIiBbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF09J2dldEF0dHJEYXRhUGF0aChpdGVtS2V5KSc+XG4gIDwvZGl2PlxuPC9uZy1jb250YWluZXI+XG48ZGl2ICpuZ0lmPVwiaXNJbkVkaXRNb2RlXCIgW2F0dHIuZGF0YS1jcS1kYXRhLXBhdGhdPVwicGxhY2Vob2xkZXJQYXRoXCIgW2NsYXNzXT1cImdldFBsYWNlaG9sZGVyQ2xhc3NOYW1lcygpXCI+PC9kaXY+XG5cblxuYCxcbn0pXG4vKipcbiAqIFRoZSBjdXJyZW50IGNsYXNzIGNhcnJpZXMgdGhlIGJhc2UgcHJlc2VudGF0aW9uYWwgbG9naWMgb2YgdGhlIEFFTSBMYXlvdXQgQ29udGFpbmVyIChha2EuIFJlc3BvbnNpdmUgZ3JpZClcbiAqL1xuZXhwb3J0IGNsYXNzIEFFTVJlc3BvbnNpdmVHcmlkQ29tcG9uZW50IGV4dGVuZHMgQUVNQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENsYXNzIG5hbWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCByZXNwb25zaXZlIGdyaWRcbiAgICovXG4gIEBJbnB1dCgpIGdyaWRDbGFzc05hbWVzOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBNYXAgb2YgY2xhc3MgbmFtZXMgY29ycmVzcG9uZGluZyB0byBlYWNoIGNoaWxkIG9mIHRoZSBjdXJyZW50IHJlc3BvbnNpdmUgZ3JpZFxuICAgKi9cbiAgQElucHV0KCkgY29sdW1uQ2xhc3NOYW1lczogT2JqZWN0O1xuICAvKipcbiAgICogQ2xhc3MgbmFtZXMgb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50XG4gICAqL1xuICBASW5wdXQoKSBjbGFzc05hbWVzOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDdXJyZW50IG51bWJlciBvZiBjb2x1bW5zIG9mIHRoZSBncmlkXG4gICAqL1xuICBASW5wdXQoKSBjb2x1bW5Db3VudDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb2x1bW4gY2xhc3MgbmFtZXMgZm9yIGEgZ2l2ZW4gY29sdW1uXG4gICAqIEBwYXJhbSBpdGVtS2V5IC0gVGhlIGtleSBvZiB0aGUgY29sdW1uIGl0ZW1cbiAgICovXG4gIGdldENvbHVtbkNsYXNzTmFtZXMoaXRlbUtleTpzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5DbGFzc05hbWVzICYmIHRoaXMuY29sdW1uQ2xhc3NOYW1lc1tpdGVtS2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjbGFzc2VzXG4gICAqL1xuICBnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFBsYWNlaG9sZGVyQ2xhc3NOYW1lcygpICsgUExBQ0VIT0xERVJfQ0xBU1NfTkFNRVM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xhc3MgbmFtZXMgb2YgdGhlIHJlc3BvbnNpdmUgZ3JpZCBiYXNlZCBvbiB0aGUgZGF0YSBmcm9tIHRoZSBjcU1vZGVsXG4gICAqL1xuICBnZXRIb3N0Q2xhc3NOYW1lcygpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IHN1cGVyLmdldEhvc3RDbGFzc05hbWVzKCk7XG5cbiAgICBpZiAodGhpcy5jbGFzc05hbWVzKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgKz0gJyAnICsgKHRoaXMuY2xhc3NOYW1lcyB8fCAnJykgO1xuICAgIH1cblxuICAgIHJldHVybiBjbGFzc05hbWVzICsgJyAnICsgdGhpcy5ncmlkQ2xhc3NOYW1lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhZ2dyZWdhdGVkIHBhdGggb2YgdGhpcyBjb250YWluZXIgcGF0aCBhbmQgdGhlIHByb3ZpZGVkIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIHBhdGggLSB0aGUgcHJvdmlkZWQgcGF0aCB0byBhZ2dyZWdhdGUgd2l0aCB0aGUgY29udGFpbmVyIHBhdGhcbiAgICovXG4gIGdldEF0dHJEYXRhUGF0aChwYXRoKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLmdldEl0ZW0ocGF0aCk7XG4gICAgaWYgKGl0ZW0gJiYgaXRlbVtDb25zdGFudHMuVFlQRV9QUk9QXSA9PT0gUkVTUE9OU0lWRV9HUklEX1RZUEUpIHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWRkIHRoZSBwYXRoIGZvciB0aGUgd3JhcHBlciBmb3IgYSByZXBvbnNpdmVncmlkXG4gICAgICAvLyBUaGUgcmVwb25zaXZlZ3JpZCBhZGRzIHRoZSBwYXRoIG9uIGl0J3Mgb3duXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXREYXRhUGF0aChwYXRoKTtcbiAgfVxufVxuIiwiLypcbiAqIEFET0JFIENPTkZJREVOVElBTFxuICpcbiAqIENvcHlyaWdodCAyMDE4IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVElDRTogIEFsbCBpbmZvcm1hdGlvbiBjb250YWluZWQgaGVyZWluIGlzLCBhbmQgcmVtYWluc1xuICogdGhlIHByb3BlcnR5IG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHMgc3VwcGxpZXJzLFxuICogaWYgYW55LiAgVGhlIGludGVsbGVjdHVhbCBhbmQgdGVjaG5pY2FsIGNvbmNlcHRzIGNvbnRhaW5lZFxuICogaGVyZWluIGFyZSBwcm9wcmlldGFyeSB0byBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzXG4gKiBzdXBwbGllcnMgYW5kIG1heSBiZSBjb3ZlcmVkIGJ5IFUuUy4gYW5kIEZvcmVpZ24gUGF0ZW50cyxcbiAqIHBhdGVudHMgaW4gcHJvY2VzcywgYW5kIGFyZSBwcm90ZWN0ZWQgYnkgdHJhZGUgc2VjcmV0IG9yIGNvcHlyaWdodCBsYXcuXG4gKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcbiAqIGlzIHN0cmljdGx5IGZvcmJpZGRlbiB1bmxlc3MgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uIGlzIG9idGFpbmVkXG4gKiBmcm9tIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTW9kZWxNYW5hZ2VyIH0gZnJvbSBcIkBhZG9iZS9jcS1zcGEtcGFnZS1tb2RlbC1tYW5hZ2VyXCI7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1thZW1Nb2RlbFByb3ZpZGVyXScsXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciBbYWVtQ29tcG9uZW50XSBbY3FJdGVtXT0nY3FJdGVtJyBbY3FQYXRoXT0nY3FQYXRoJyBbaXRlbU5hbWVdPSdpdGVtTmFtZSc+PC9uZy1jb250YWluZXI+YFxufSlcbi8qKlxuICogVGhlIGN1cnJlbnQgY29tcG9uZW50IGlzIHJlc3BvbnNpYmxlIGZvciBwcm92aWRpbmcgYWNjZXNzIHRvIHRoZSBNb2RlbE1hbmFnZXIgYW5kIHRoZSBtb2RlbCBvZiBhIGNvbXBvbmVudFxuICovXG5leHBvcnQgY2xhc3MgQUVNTW9kZWxQcm92aWRlckNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY3FQYXRoO1xuICAvKipcbiAgICogTW9kZWwgaXRlbSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbW9kZWwgcHJvdmlkZXIgY29tcG9uZW50XG4gICAqL1xuICBASW5wdXQoKSBjcUl0ZW07XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBpdGVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBtb2RlbCBwcm92aWRlciBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGl0ZW1OYW1lO1xuXG4gIEBJbnB1dCgpIGFlbU1vZGVsUHJvdmlkZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGl0ZW0gZGF0YVxuICAgKi9cbiAgdXBkYXRlSXRlbSgpIHtcbiAgICBNb2RlbE1hbmFnZXIuZ2V0RGF0YSh7cGF0aDogdGhpcy5jcVBhdGh9KS50aGVuKG1vZGVsID0+IHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNxSXRlbSA9IG1vZGVsO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIE1vZGVsTWFuYWdlci5hZGRMaXN0ZW5lcih0aGlzLmNxUGF0aCwgdGhpcy51cGRhdGVJdGVtLmJpbmQodGhpcykpO1xuICB9XG5cbiAgbmdEZXN0cm95KCkge1xuICAgIE1vZGVsTWFuYWdlci5yZW1vdmVMaXN0ZW5lcih0aGlzLmNxUGF0aCwgdGhpcy51cGRhdGVJdGVtLmJpbmQodGhpcykpO1xuICB9XG59XG5cbiIsIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFFTUNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4uL2FlbS1jb250YWluZXIvYWVtLWNvbnRhaW5lci5jb21wb25lbnQnO1xuXG5jb25zdCBQQUdFX01PREVMX1NFUEFSQVRPUiA9ICcvamNyOmNvbnRlbnQvJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYWVtLXBhZ2UnLFxuICBob3N0OiB7XG4gICAgICAnW2NsYXNzXSc6ICdob3N0Q2xhc3NlcycsXG4gICAgICAnW2F0dHIuZGF0YS1jcS1kYXRhLXBhdGhdJzonY3FQYXRoJ1xuICB9LFxuICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW1LZXkgb2YgY3FJdGVtc09yZGVyXCI+XG4gIDxuZy1jb250YWluZXIgW2FlbUNvbXBvbmVudF0gW2NxSXRlbV09J2dldEl0ZW0oaXRlbUtleSknIFtjcVBhdGhdPSdnZXREYXRhUGF0aChpdGVtS2V5KScgW2l0ZW1OYW1lXT0naXRlbUtleSc+PC9uZy1jb250YWluZXI+XG4gIDxkaXYgKm5nSWY9XCJpc0luRWRpdE1vZGVcIiBbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF09XCJwbGFjZWhvbGRlclBhdGhcIiBbY2xhc3NdPVwiZ2V0UGxhY2Vob2xkZXJDbGFzc05hbWVzKClcIj48L2Rpdj5cbjwvbmctY29udGFpbmVyPlxuYFxufSlcbi8qKlxuICogVGhlIGN1cnJlbnQgY29tcG9uZW50IGNhcnJpZXMgdGhlIGJhc2UgcHJlc2VudGF0aW9uYWwgbG9naWMgb2YgcGFnZSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEFFTVBhZ2VDb21wb25lbnQgZXh0ZW5kcyBBRU1Db250YWluZXJDb21wb25lbnQge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWdncmVnYXRlZCBwYXRoIG9mIHRoaXMgY29udGFpbmVyIHBhdGggYW5kIHRoZSBwcm92aWRlZCBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIC0gdGhlIHByb3ZpZGVkIHBhdGggdG8gYWdncmVnYXRlIHdpdGggdGhlIGNvbnRhaW5lciBwYXRoXG4gICAqL1xuICBnZXREYXRhUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3FQYXRoID8gdGhpcy5jcVBhdGggKyBQQUdFX01PREVMX1NFUEFSQVRPUiArIHBhdGggOiBwYXRoO1xuICB9XG5cbn1cblxuIiwiLypcbiAqICBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqICBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBRU1Db21wb25lbnREaXJlY3RpdmUgfSBmcm9tIFwiLi9sYXlvdXQvYWVtLWNvbXBvbmVudC5kaXJlY3RpdmVcIjtcbmltcG9ydCB7IEFFTU1vZGVsUHJvdmlkZXJDb21wb25lbnQgfSBmcm9tIFwiLi9sYXlvdXQvYWVtLW1vZGVsLXByb3ZpZGVyL2FlbS1tb2RlbC1wcm92aWRlci5jb21wb25lbnRcIjtcbmltcG9ydCB7IEFFTUNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gXCIuL2xheW91dC9hZW0tY29udGFpbmVyL2FlbS1jb250YWluZXIuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBRU1QYWdlQ29tcG9uZW50IH0gZnJvbSBcIi4vbGF5b3V0L2FlbS1wYWdlL2FlbS1wYWdlLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQUVNUmVzcG9uc2l2ZUdyaWRDb21wb25lbnQgfSBmcm9tIFwiLi9sYXlvdXQvYWVtLXJlc3BvbnNpdmVncmlkL2FlbS1yZXNwb25zaXZlZ3JpZC5jb21wb25lbnRcIjtcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuXG4gIGRlY2xhcmF0aW9uczogW0FFTUNvbnRhaW5lckNvbXBvbmVudCwgQUVNUmVzcG9uc2l2ZUdyaWRDb21wb25lbnQsIEFFTUNvbXBvbmVudERpcmVjdGl2ZSwgQUVNTW9kZWxQcm92aWRlckNvbXBvbmVudCwgQUVNUGFnZUNvbXBvbmVudF0sXG4gIGV4cG9ydHM6IFtBRU1Db250YWluZXJDb21wb25lbnQsIEFFTVJlc3BvbnNpdmVHcmlkQ29tcG9uZW50LCBBRU1Db21wb25lbnREaXJlY3RpdmUsIEFFTU1vZGVsUHJvdmlkZXJDb21wb25lbnQsIEFFTVBhZ2VDb21wb25lbnRdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtBRU1Db250YWluZXJDb21wb25lbnQsIEFFTVJlc3BvbnNpdmVHcmlkQ29tcG9uZW50LCBBRU1QYWdlQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBTcGFBbmd1bGFyRWRpdGFibGVDb21wb25lbnRzTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzb2x2ZSwgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBZW1QYWdlRGF0YVJlc29sdmVyIGltcGxlbWVudHMgUmVzb2x2ZSA8IHN0cmluZyA+IHtcbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhYnNvbHV0ZSByZXNvdXJjZSBwYXRoIHdpdGhvdXQgZXh0ZW5zaW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyByZXR1cm5zOiAnL2NvbnRlbnQvYWEvYmInIGZvciByb3V0ZS51cmwgWyAnY29udGVudCcsICdhYScsICdiYi5odG1sJyBdXG4gICAqIHJlc29sdmUocm91dGUpXG4gICAqIEBwYXJhbSByb3V0ZSAtIHJvdXRlXG4gICAqIEByZXR1cm5zIGFic29sdXRlIHJlc291cmNlIHBhdGggd2l0aG91dCBleHRlbnNpb25cbiAgICovXG4gIHJlc29sdmUocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpIHtcbiAgICByZXR1cm4gJy8nICsgcm91dGUudXJsLmpvaW4oJy8nKS5yZXBsYWNlKC9cXC5bXi8uXSskLywgJycpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBSb3V0ZVJldXNlU3RyYXRlZ3ksIERldGFjaGVkUm91dGVIYW5kbGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG4vKipcbiAqIEltcGxlbWVudHMgUm91dGVSZXVzZVN0cmF0ZWd5IHRvIGN1c3RvbWl6ZSByb3V0ZSByZXVzZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEFlbVBhZ2VSb3V0ZVJldXNlU3RyYXRlZ3kgaW1wbGVtZW50cyBSb3V0ZVJldXNlU3RyYXRlZ3kge1xuICAvKiogRGV0ZXJtaW5lcyBpZiB0aGlzIHJvdXRlIChhbmQgaXRzIHN1YnRyZWUpIHNob3VsZCBiZSBkZXRhY2hlZCB0byBiZSByZXVzZWQgbGF0ZXIuICovXG4gIHNob3VsZERldGFjaChyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBOb3Qgc3RvcmluZyBkZXRlYWNoZWQgcm91dGUuICovXG4gIHN0b3JlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBkZXRhY2hlZFRyZWU6IERldGFjaGVkUm91dGVIYW5kbGUpOiB2b2lkIHt9XG5cbiAgLyoqIERldGVybWluZXMgaWYgdGhpcyByb3V0ZSAoYW5kIGl0cyBzdWJ0cmVlKSBzaG91bGQgYmUgcmVhdHRhY2hlZC4gKi9cbiAgc2hvdWxkQXR0YWNoKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIFJldHJpZXZlcyB0aGUgcHJldmlvdXNseSBzdG9yZWQgcm91dGUuICovXG4gIHJldHJpZXZlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogRGV0YWNoZWRSb3V0ZUhhbmRsZSB8IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIERldGVybWluZXMgaWYgYSByb3V0ZSBzaG91bGQgYmUgcmV1c2VkICovXG4gIHNob3VsZFJldXNlUm91dGUoZnV0dXJlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBjdXJyOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiU1BBQ29tcG9uZW50TWFwcGluZyIsIkNvbnN0YW50cyIsIlBNQ29uc3RhbnRzIiwiQ29tcG9uZW50TWFwcGluZyIsIlBMQUNFSE9MREVSX0NMQVNTX05BTUVTIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQXdCQTs7OztJQU1FLFlBQW9CLFVB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