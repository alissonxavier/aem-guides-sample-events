(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@adobe/cq-spa-component-mapping'), require('@adobe/cq-spa-page-model-manager'), require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@adobe/cq-angular-editable-components', ['exports', '@adobe/cq-spa-component-mapping', '@adobe/cq-spa-page-model-manager', '@angular/core', '@angular/common'], factory) :
    (factory((global.adobe = global.adobe || {}, global.adobe['cq-angular-editable-components'] = {}),null,null,global.ng.core,global.ng.common));
}(this, (function (exports,cqSpaComponentMapping,cqSpaPageModelManager,core,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The current class extends the \@adobe/cq-spa-component-mapping#Mapto library and features with Angular specifics such as
     *
     * - Storing the editing configurations for each resource type
     */
    var /**
     * The current class extends the \@adobe/cq-spa-component-mapping#Mapto library and features with Angular specifics such as
     *
     * - Storing the editing configurations for each resource type
     */ ComponentMappingWithConfig = (function () {
        function ComponentMappingWithConfig(spaMapping) {
            this.spaMapping = spaMapping;
            /**
             * Store of EditConfig structures
             */
            this.editConfigMap = {};
        }
        /**
         * Stores a component class for the given resource types and also allows to provide an EditConfig object
         * @param resourceTypes - List of resource types
         * @param clazz - Component class to be stored
         * @param [editConfig] - Edit configuration to be stored for the given resource types
         */
        /**
         * Stores a component class for the given resource types and also allows to provide an EditConfig object
         * @param {?} resourceTypes - List of resource types
         * @param {?} clazz - Component class to be stored
         * @param {?=} editConfig
         * @return {?}
         */
        ComponentMappingWithConfig.prototype.map = /**
         * Stores a component class for the given resource types and also allows to provide an EditConfig object
         * @param {?} resourceTypes - List of resource types
         * @param {?} clazz - Component class to be stored
         * @param {?=} editConfig
         * @return {?}
         */
            function (resourceTypes, clazz, editConfig) {
                if (editConfig === void 0) {
                    editConfig = null;
                }
                var /** @type {?} */ innerClass = clazz;
                if (editConfig) {
                    this.editConfigMap[resourceTypes] = editConfig;
                }
                this.spaMapping.map(resourceTypes, innerClass);
            };
        /**
         * Returns the component class for the given resourceType
         * @param resourceType - Resource type for which the component class has been stored
         */
        /**
         * Returns the component class for the given resourceType
         * @param {?} resourceType - Resource type for which the component class has been stored
         * @return {?}
         */
        ComponentMappingWithConfig.prototype.get = /**
         * Returns the component class for the given resourceType
         * @param {?} resourceType - Resource type for which the component class has been stored
         * @return {?}
         */
            function (resourceType) {
                return this.spaMapping.get(resourceType);
            };
        /**
         * Returns the EditConfig structure for the given type
         * @param resourceType - Resource type for which the configuration has been stored
         */
        /**
         * Returns the EditConfig structure for the given type
         * @param {?} resourceType - Resource type for which the configuration has been stored
         * @return {?}
         */
        ComponentMappingWithConfig.prototype.getEditConfig = /**
         * Returns the EditConfig structure for the given type
         * @param {?} resourceType - Resource type for which the configuration has been stored
         * @return {?}
         */
            function (resourceType) {
                return this.editConfigMap[resourceType];
            };
        return ComponentMappingWithConfig;
    }());
    var /** @type {?} */ componentMapping = new ComponentMappingWithConfig(cqSpaComponentMapping.ComponentMapping);
    /**
     * @param {?} resourceTypes
     * @return {?}
     */
    function MapTo(resourceTypes) {
        return function (clazz, editConfig) {
            if (editConfig === void 0) {
                editConfig = null;
            }
            return componentMapping.map(resourceTypes, clazz, editConfig);
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ Constants = {
        /**
             * Class names associated with a new section component
             *
             */
        NEW_SECTION_CLASS_NAMES: 'new section',
        TYPE_PROP: cqSpaPageModelManager.Constants.TYPE_PROP,
        /**
             * List of child items of an item
             *
             */
        ITEMS_PROP: cqSpaPageModelManager.Constants.ITEMS_PROP,
        /**
             * Order in which the items should be listed
             *
             */
        ITEMS_ORDER_PROP: cqSpaPageModelManager.Constants.ITEMS_ORDER_PROP,
        /**
             * Path of the item
             *
             */
        PATH_PROP: cqSpaPageModelManager.Constants.PATH_PROP,
        /**
             * Children of an item
             *
             */
        CHILDREN_PROP: cqSpaPageModelManager.Constants.CHILDREN_PROP,
        /**
             * Path of the resource in the model
             *
             */
        DATA_PATH_PROP: ':dataPath',
        /**
             * Hierarchical type of the item
             */
        HIERARCHY_TYPE_PROP: cqSpaPageModelManager.Constants.HIERARCHY_TYPE_PROP
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /*
     * ADOBE CONFIDENTIAL
     *
     * Copyright 2018 Adobe Systems Incorporated
     * All Rights Reserved.
     *
     * NOTICE:  All information contained herein is, and remains
     * the property of Adobe Systems Incorporated and its suppliers,
     * if any.  The intellectual and technical concepts contained
     * herein are proprietary to Adobe Systems Incorporated and its
     * suppliers and may be covered by U.S. and Foreign Patents,
     * patents in process, and are protected by trade secret or copyright law.
     * Dissemination of this information or reproduction of this material
     * is strictly forbidden unless prior written permission is obtained
     * from Adobe Systems Incorporated.
     */
    /**
     * Selector that identifies the node that contains the WCM mode state
     */
    var /** @type {?} */ WCM_MODE_META_SELECTOR = 'meta[property="cq:wcmmode"]';
    /**
     * The editor is in one of the edition modes
     */
    var /** @type {?} */ EDIT_MODE = 'edit';
    /**
     * The editor is in preview mode
     */
    var /** @type {?} */ PREVIEW_MODE = 'preview';
    /**
     * Returns if we are in the browser context or not by checking for the
     * existence of the window object
     * @return {?}
     */
    function isBrowser() {
        try {
            return typeof window !== 'undefined';
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Returns the current WCM mode
     *
     * <p>Note that the value isn't, as of the date of this writing, updated by the editor</p>
     * @return {?}
     */
    function getWCMMode() {
        if (isBrowser()) {
            var /** @type {?} */ wcmModeMeta = document.head.querySelector(WCM_MODE_META_SELECTOR);
            return wcmModeMeta && wcmModeMeta.content;
        }
    }
    /**
     * Helper functions for interacting with the AEM environment
     */
    var /** @type {?} */ Utils = {
        /**
         * Is the app used in the context of the AEM Page editor
         */
        isInEditor: /**
         * Is the app used in the context of the AEM Page editor
         * @return {?}
         */ function () {
            var /** @type {?} */ wcmMode = getWCMMode();
            return wcmMode && (EDIT_MODE === wcmMode || PREVIEW_MODE === wcmMode);
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ PLACEHOLDER_CLASS_NAME = 'cq-placeholder';
    var AEMComponentDirective = (function () {
        function AEMComponentDirective(renderer, viewContainer, factoryResolver, ngZone) {
            this.renderer = renderer;
            this.viewContainer = viewContainer;
            this.factoryResolver = factoryResolver;
            this.ngZone = ngZone;
        }
        Object.defineProperty(AEMComponentDirective.prototype, "cqItem", {
            get: /**
             * @return {?}
             */ function () {
                return this._cqItem;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._cqItem = value;
                this.updateComponentData();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        AEMComponentDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.renderComponent(componentMapping.get(this.type));
            };
        Object.defineProperty(AEMComponentDirective.prototype, "type", {
            /**
             * Returns the type of the cqItem if exists.
             */
            get: /**
             * Returns the type of the cqItem if exists.
             * @return {?}
             */ function () {
                return this.cqItem && this.cqItem[Constants.TYPE_PROP];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Renders a component dynamically based on the component definition
         *
         * @param {?} componentDefinition The component definition to render
         * @return {?}
         */
        AEMComponentDirective.prototype.renderComponent = /**
         * Renders a component dynamically based on the component definition
         *
         * @param {?} componentDefinition The component definition to render
         * @return {?}
         */
            function (componentDefinition) {
                if (componentDefinition) {
                    var /** @type {?} */ factory = this.factoryResolver.resolveComponentFactory(componentDefinition);
                    this.viewContainer.clear();
                    this._component = this.viewContainer.createComponent(factory);
                    this.updateComponentData();
                }
            };
        /**
         * Updates the data of the component based the data of the directive
         * @return {?}
         */
        AEMComponentDirective.prototype.updateComponentData = /**
         * Updates the data of the component based the data of the directive
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this._component || !this._component.instance) {
                    return;
                }
                var /** @type {?} */ keys = Object.getOwnPropertyNames(this.cqItem);
                keys.forEach(function (key) {
                    var /** @type {?} */ propKey = key;
                    if (propKey.startsWith(":")) {
                        // Transformation of internal properties namespaced with [:] to [cq]
                        // :myProperty => cqMyProperty
                        var /** @type {?} */ tempKey = propKey.substr(1);
                        propKey = "cq" + tempKey.substr(0, 1).toUpperCase() + tempKey.substr(1);
                    }
                    _this._component.instance[propKey] = _this.cqItem[key];
                });
                this._component.instance.cqPath = this.cqPath;
                this._component.instance.itemName = this.itemName;
                var /** @type {?} */ editConfig = componentMapping.getEditConfig(this.type);
                if (editConfig && Utils.isInEditor) {
                    this.setupPlaceholder(editConfig);
                }
            };
        /**
         * Adds the specified item attributes to the element
         * @return {?}
         */
        AEMComponentDirective.prototype.setupItemAttrs = /**
         * Adds the specified item attributes to the element
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.itemAttrs) {
                    var /** @type {?} */ keys = Object.getOwnPropertyNames(this.itemAttrs);
                    keys.forEach(function (key) {
                        if (key === "class") {
                            var /** @type {?} */ classes = _this.itemAttrs[key].split(' ');
                            classes.forEach(function (itemClass) {
                                _this.renderer.addClass(_this._component.location.nativeElement, itemClass);
                            });
                        }
                        else {
                            _this.renderer.setAttribute(_this._component.location.nativeElement, key, _this.itemAttrs[key]);
                        }
                    });
                }
            };
        /**
         * Determines if the placeholder should e displayed.
         *
         * @param {?} editConfig - the edit config of the directive
         * @return {?}
         */
        AEMComponentDirective.prototype.usePlaceholder = /**
         * Determines if the placeholder should e displayed.
         *
         * @param {?} editConfig - the edit config of the directive
         * @return {?}
         */
            function (editConfig) {
                return editConfig.isEmpty && typeof editConfig.isEmpty === "function" && editConfig.isEmpty(this.cqItem);
            };
        /**
         * Setups the placeholder of needed for the AEM editor
         *
         * @param {?} editConfig - the editConfig, which will dictate the classes to be added on.
         * @return {?}
         */
        AEMComponentDirective.prototype.setupPlaceholder = /**
         * Setups the placeholder of needed for the AEM editor
         *
         * @param {?} editConfig - the editConfig, which will dictate the classes to be added on.
         * @return {?}
         */
            function (editConfig) {
                if (this.usePlaceholder(editConfig)) {
                    this.renderer.addClass(this._component.location.nativeElement, PLACEHOLDER_CLASS_NAME);
                    this.renderer.setAttribute(this._component.location.nativeElement, "data-emptytext", editConfig.emptyLabel);
                }
                else {
                    this.renderer.removeClass(this._component.location.nativeElement, PLACEHOLDER_CLASS_NAME);
                    this.renderer.removeAttribute(this._component.location.nativeElement, "data-emptytext");
                }
            };
        /**
         * @return {?}
         */
        AEMComponentDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.setupItemAttrs();
            };
        /**
         * @return {?}
         */
        AEMComponentDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._component && this._component.destroy();
            };
        AEMComponentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[aemComponent]'
                    },] },
        ];
        /** @nocollapse */
        AEMComponentDirective.ctorParameters = function () {
            return [
                { type: core.Renderer2, },
                { type: core.ViewContainerRef, },
                { type: core.ComponentFactoryResolver, },
                { type: core.NgZone, },
            ];
        };
        AEMComponentDirective.propDecorators = {
            "cqItem": [{ type: core.Input },],
            "cqPath": [{ type: core.Input },],
            "itemName": [{ type: core.Input },],
            "itemAttrs": [{ type: core.Input },],
            "aemComponent": [{ type: core.Input },],
        };
        return AEMComponentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ PLACEHOLDER_CLASS_NAMES = Constants.NEW_SECTION_CLASS_NAMES;
    var /** @type {?} */ PLACEHOLDER_ITEM_NAME = '*';
    var /** @type {?} */ CONTAINER_CLASS_NAMES = 'aem-container';
    var AEMContainerComponent = (function () {
        function AEMContainerComponent() {
            /**
             * Path to the model associated with the current instance of the component
             */
            this.cqPath = '';
            /**
             * Key of the model structure
             */
            this.modelName = '';
        }
        Object.defineProperty(AEMContainerComponent.prototype, "isInEditMode", {
            /**
             * Returns weather of not we are in the editor
             */
            get: /**
             * Returns weather of not we are in the editor
             * @return {?}
             */ function () {
                return Utils.isInEditor();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param path - the provided path to aggregate with the container path
         */
        /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param {?} path - the provided path to aggregate with the container path
         * @return {?}
         */
        AEMContainerComponent.prototype.getDataPath = /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param {?} path - the provided path to aggregate with the container path
         * @return {?}
         */
            function (path) {
                return this.cqPath ? this.cqPath + '/' + path : path;
            };
        /**
         * Returns the item data from the cqModel
         *
         * @param itemKey - the itemKey to look for in the items.
         */
        /**
         * Returns the item data from the cqModel
         *
         * @param {?} itemKey - the itemKey to look for in the items.
         * @return {?}
         */
        AEMContainerComponent.prototype.getItem = /**
         * Returns the item data from the cqModel
         *
         * @param {?} itemKey - the itemKey to look for in the items.
         * @return {?}
         */
            function (itemKey) {
                return this.cqItems && this.cqItems[itemKey];
            };
        /**
         * Returns the class names of the container based on the data from the cqModel
         */
        /**
         * Returns the class names of the container based on the data from the cqModel
         * @return {?}
         */
        AEMContainerComponent.prototype.getHostClassNames = /**
         * Returns the class names of the container based on the data from the cqModel
         * @return {?}
         */
            function () {
                return CONTAINER_CLASS_NAMES;
            };
        Object.defineProperty(AEMContainerComponent.prototype, "hostClasses", {
            get: /**
             * @return {?}
             */ function () {
                return this.getHostClassNames();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the placeholder classes
         */
        /**
         * Returns the placeholder classes
         * @return {?}
         */
        AEMContainerComponent.prototype.getPlaceholderClassNames = /**
         * Returns the placeholder classes
         * @return {?}
         */
            function () {
                return PLACEHOLDER_CLASS_NAMES;
            };
        Object.defineProperty(AEMContainerComponent.prototype, "placeholderPath", {
            /**
             * Returns the placeholder path
             */
            get: /**
             * Returns the placeholder path
             * @return {?}
             */ function () {
                return this.cqPath && this.cqPath + '/' + PLACEHOLDER_ITEM_NAME;
            },
            enumerable: true,
            configurable: true
        });
        AEMContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aem-container',
                        host: {
                            '[class]': 'hostClasses',
                            '[attr.data-cq-data-path]': 'cqPath'
                        },
                        template: "<ng-container *ngFor=\"let itemKey of cqItemsOrder\">\n  <ng-container [aemComponent] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey'></ng-container>\n  <div *ngIf=\"isInEditMode\" [attr.data-cq-data-path]=\"placeholderPath\" [class]=\"getPlaceholderClassNames()\"></div>\n</ng-container>\n"
                    },] },
        ];
        /** @nocollapse */
        AEMContainerComponent.propDecorators = {
            "cqItems": [{ type: core.Input },],
            "cqItemsOrder": [{ type: core.Input },],
            "cqPath": [{ type: core.Input },],
            "modelName": [{ type: core.Input },],
            "classNames": [{ type: core.Input },],
        };
        return AEMContainerComponent;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ PLACEHOLDER_CLASS_NAMES$1 = ' aem-Grid-newComponent';
    var /** @type {?} */ RESPONSIVE_GRID_TYPE = 'wcm/foundation/components/responsivegrid';
    var AEMResponsiveGridComponent = (function (_super) {
        __extends(AEMResponsiveGridComponent, _super);
        function AEMResponsiveGridComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the column class names for a given column
         * @param itemKey - The key of the column item
         */
        /**
         * Returns the column class names for a given column
         * @param {?} itemKey - The key of the column item
         * @return {?}
         */
        AEMResponsiveGridComponent.prototype.getColumnClassNames = /**
         * Returns the column class names for a given column
         * @param {?} itemKey - The key of the column item
         * @return {?}
         */
            function (itemKey) {
                return this.columnClassNames && this.columnClassNames[itemKey];
            };
        /**
         * Returns the placeholder classes
         */
        /**
         * Returns the placeholder classes
         * @return {?}
         */
        AEMResponsiveGridComponent.prototype.getPlaceholderClassNames = /**
         * Returns the placeholder classes
         * @return {?}
         */
            function () {
                return _super.prototype.getPlaceholderClassNames.call(this) + PLACEHOLDER_CLASS_NAMES$1;
            };
        /**
         * Returns the class names of the responsive grid based on the data from the cqModel
         */
        /**
         * Returns the class names of the responsive grid based on the data from the cqModel
         * @return {?}
         */
        AEMResponsiveGridComponent.prototype.getHostClassNames = /**
         * Returns the class names of the responsive grid based on the data from the cqModel
         * @return {?}
         */
            function () {
                var /** @type {?} */ classNames = _super.prototype.getHostClassNames.call(this);
                if (this.classNames) {
                    classNames += ' ' + (this.classNames || '');
                }
                return classNames + ' ' + this.gridClassNames;
            };
        /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param path - the provided path to aggregate with the container path
         */
        /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param {?} path - the provided path to aggregate with the container path
         * @return {?}
         */
        AEMResponsiveGridComponent.prototype.getAttrDataPath = /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param {?} path - the provided path to aggregate with the container path
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ item = this.getItem(path);
                if (item && item[Constants.TYPE_PROP] === RESPONSIVE_GRID_TYPE) {
                    // We don't want to add the path for the wrapper for a reponsivegrid
                    // The reponsivegrid adds the path on it's own
                    return null;
                }
                return this.getDataPath(path);
            };
        AEMResponsiveGridComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aem-responsivegrid',
                        host: {
                            '[class]': 'hostClasses',
                            '[attr.data-cq-data-path]': 'cqPath'
                        },
                        template: "<ng-container *ngFor=\"let itemKey of cqItemsOrder\">\n  <div [aemModelProvider] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey' [class]=\"getColumnClassNames(itemKey)\" [attr.data-cq-data-path]='getAttrDataPath(itemKey)'>\n  </div>\n</ng-container>\n<div *ngIf=\"isInEditMode\" [attr.data-cq-data-path]=\"placeholderPath\" [class]=\"getPlaceholderClassNames()\"></div>\n\n\n",
                    },] },
        ];
        /** @nocollapse */
        AEMResponsiveGridComponent.propDecorators = {
            "gridClassNames": [{ type: core.Input },],
            "columnClassNames": [{ type: core.Input },],
            "classNames": [{ type: core.Input },],
            "columnCount": [{ type: core.Input },],
        };
        return AEMResponsiveGridComponent;
    }(AEMContainerComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AEMModelProviderComponent = (function () {
        function AEMModelProviderComponent(ngZone) {
            this.ngZone = ngZone;
        }
        /**
         * Updates the item data
         */
        /**
         * Updates the item data
         * @return {?}
         */
        AEMModelProviderComponent.prototype.updateItem = /**
         * Updates the item data
         * @return {?}
         */
            function () {
                var _this = this;
                cqSpaPageModelManager.ModelManager.getData({ path: this.cqPath }).then(function (model) {
                    _this.ngZone.run(function () {
                        _this.cqItem = model;
                    });
                });
            };
        /**
         * @return {?}
         */
        AEMModelProviderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                cqSpaPageModelManager.ModelManager.addListener(this.cqPath, this.updateItem.bind(this));
            };
        /**
         * @return {?}
         */
        AEMModelProviderComponent.prototype.ngDestroy = /**
         * @return {?}
         */
            function () {
                cqSpaPageModelManager.ModelManager.removeListener(this.cqPath, this.updateItem.bind(this));
            };
        AEMModelProviderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: '[aemModelProvider]',
                        template: "<ng-container [aemComponent] [cqItem]='cqItem' [cqPath]='cqPath' [itemName]='itemName'></ng-container>"
                    },] },
        ];
        /** @nocollapse */
        AEMModelProviderComponent.ctorParameters = function () {
            return [
                { type: core.NgZone, },
            ];
        };
        AEMModelProviderComponent.propDecorators = {
            "cqPath": [{ type: core.Input },],
            "cqItem": [{ type: core.Input },],
            "itemName": [{ type: core.Input },],
            "aemModelProvider": [{ type: core.Input },],
        };
        return AEMModelProviderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ PAGE_MODEL_SEPARATOR = '/jcr:content/';
    var AEMPageComponent = (function (_super) {
        __extends(AEMPageComponent, _super);
        function AEMPageComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param path - the provided path to aggregate with the container path
         */
        /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param {?} path - the provided path to aggregate with the container path
         * @return {?}
         */
        AEMPageComponent.prototype.getDataPath = /**
         * Returns the aggregated path of this container path and the provided path
         *
         * @param {?} path - the provided path to aggregate with the container path
         * @return {?}
         */
            function (path) {
                return this.cqPath ? this.cqPath + PAGE_MODEL_SEPARATOR + path : path;
            };
        AEMPageComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aem-page',
                        host: {
                            '[class]': 'hostClasses',
                            '[attr.data-cq-data-path]': 'cqPath'
                        },
                        template: "<ng-container *ngFor=\"let itemKey of cqItemsOrder\">\n  <ng-container [aemComponent] [cqItem]='getItem(itemKey)' [cqPath]='getDataPath(itemKey)' [itemName]='itemKey'></ng-container>\n  <div *ngIf=\"isInEditMode\" [attr.data-cq-data-path]=\"placeholderPath\" [class]=\"getPlaceholderClassNames()\"></div>\n</ng-container>\n"
                    },] },
        ];
        return AEMPageComponent;
    }(AEMContainerComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SpaAngularEditableComponentsModule = (function () {
        function SpaAngularEditableComponentsModule() {
        }
        SpaAngularEditableComponentsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [AEMContainerComponent, AEMResponsiveGridComponent, AEMComponentDirective, AEMModelProviderComponent, AEMPageComponent],
                        exports: [AEMContainerComponent, AEMResponsiveGridComponent, AEMComponentDirective, AEMModelProviderComponent, AEMPageComponent],
                        entryComponents: [AEMContainerComponent, AEMResponsiveGridComponent, AEMPageComponent]
                    },] },
        ];
        return SpaAngularEditableComponentsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AemPageDataResolver = (function () {
        function AemPageDataResolver() {
        }
        /**
         * Returns the absolute resource path without extension.
         * @example
         * // returns: '/content/aa/bb' for route.url [ 'content', 'aa', 'bb.html' ]
         * resolve(route)
         * @param route - route
         * @returns absolute resource path without extension
         */
        /**
         * Returns the absolute resource path without extension.
         * \@example
         * // returns: '/content/aa/bb' for route.url [ 'content', 'aa', 'bb.html' ]
         * resolve(route)
         * @param {?} route - route
         * @return {?} absolute resource path without extension
         */
        AemPageDataResolver.prototype.resolve = /**
         * Returns the absolute resource path without extension.
         * \@example
         * // returns: '/content/aa/bb' for route.url [ 'content', 'aa', 'bb.html' ]
         * resolve(route)
         * @param {?} route - route
         * @return {?} absolute resource path without extension
         */
            function (route) {
                return '/' + route.url.join('/').replace(/\.[^/.]+$/, '');
            };
        AemPageDataResolver.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        AemPageDataResolver.ctorParameters = function () { return []; };
        return AemPageDataResolver;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements RouteReuseStrategy to customize route reuse.
     */
    var /**
     * Implements RouteReuseStrategy to customize route reuse.
     */ AemPageRouteReuseStrategy = (function () {
        function AemPageRouteReuseStrategy() {
        }
        /** Determines if this route (and its subtree) should be detached to be reused later. */
        /**
         * Determines if this route (and its subtree) should be detached to be reused later.
         * @param {?} route
         * @return {?}
         */
        AemPageRouteReuseStrategy.prototype.shouldDetach = /**
         * Determines if this route (and its subtree) should be detached to be reused later.
         * @param {?} route
         * @return {?}
         */
            function (route) {
                return false;
            };
        /** Not storing deteached route. */
        /**
         * Not storing deteached route.
         * @param {?} route
         * @param {?} detachedTree
         * @return {?}
         */
        AemPageRouteReuseStrategy.prototype.store = /**
         * Not storing deteached route.
         * @param {?} route
         * @param {?} detachedTree
         * @return {?}
         */
            function (route, detachedTree) { };
        /** Determines if this route (and its subtree) should be reattached. */
        /**
         * Determines if this route (and its subtree) should be reattached.
         * @param {?} route
         * @return {?}
         */
        AemPageRouteReuseStrategy.prototype.shouldAttach = /**
         * Determines if this route (and its subtree) should be reattached.
         * @param {?} route
         * @return {?}
         */
            function (route) {
                return false;
            };
        /** Retrieves the previously stored route. */
        /**
         * Retrieves the previously stored route.
         * @param {?} route
         * @return {?}
         */
        AemPageRouteReuseStrategy.prototype.retrieve = /**
         * Retrieves the previously stored route.
         * @param {?} route
         * @return {?}
         */
            function (route) {
                return null;
            };
        /** Determines if a route should be reused */
        /**
         * Determines if a route should be reused
         * @param {?} future
         * @param {?} curr
         * @return {?}
         */
        AemPageRouteReuseStrategy.prototype.shouldReuseRoute = /**
         * Determines if a route should be reused
         * @param {?} future
         * @param {?} curr
         * @return {?}
         */
            function (future, curr) {
                return false;
            };
        return AemPageRouteReuseStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.AEMComponentDirective = AEMComponentDirective;
    exports.AEMContainerComponent = AEMContainerComponent;
    exports.AEMResponsiveGridComponent = AEMResponsiveGridComponent;
    exports.ComponentMappingWithConfig = ComponentMappingWithConfig;
    exports.ComponentMapping = componentMapping;
    exports.MapTo = MapTo;
    exports.Constants = Constants;
    exports.Utils = Utils;
    exports.SpaAngularEditableComponentsModule = SpaAngularEditableComponentsModule;
    exports.AemPageDataResolver = AemPageDataResolver;
    exports.AemPageRouteReuseStrategy = AemPageRouteReuseStrategy;
    exports.ɵa = AEMModelProviderComponent;
    exports.ɵb = AEMPageComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRvYmUtY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvbGF5b3V0L2NvbXBvbmVudC1tYXBwaW5nLnRzIiwibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvY29uc3RhbnRzLnRzIiwibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvdXRpbHMudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2xheW91dC9hZW0tY29tcG9uZW50LmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvbGF5b3V0L2FlbS1jb250YWluZXIvYWVtLWNvbnRhaW5lci5jb21wb25lbnQudHMiLG51bGwsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvbGF5b3V0L2FlbS1yZXNwb25zaXZlZ3JpZC9hZW0tcmVzcG9uc2l2ZWdyaWQuY29tcG9uZW50LnRzIiwibmc6Ly9AYWRvYmUvY3EtYW5ndWxhci1lZGl0YWJsZS1jb21wb25lbnRzL2xpYi9sYXlvdXQvYWVtLW1vZGVsLXByb3ZpZGVyL2FlbS1tb2RlbC1wcm92aWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2xheW91dC9hZW0tcGFnZS9hZW0tcGFnZS5jb21wb25lbnQudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy5tb2R1bGUudHMiLCJuZzovL0BhZG9iZS9jcS1hbmd1bGFyLWVkaXRhYmxlLWNvbXBvbmVudHMvbGliL3JvdXRpbmcvQWVtUGFnZURhdGFSZXNvbHZlci50cyIsIm5nOi8vQGFkb2JlL2NxLWFuZ3VsYXItZWRpdGFibGUtY29tcG9uZW50cy9saWIvcm91dGluZy9BZW1QYWdlUm91dGVSZXVzZVN0cmF0ZWd5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnRNYXBwaW5nIGFzIFNQQUNvbXBvbmVudE1hcHBpbmcgfSBmcm9tICdAYWRvYmUvY3Etc3BhLWNvbXBvbmVudC1tYXBwaW5nJztcblxuLyoqXG4gKiBUaGUgY3VycmVudCBjbGFzcyBleHRlbmRzIHRoZSBAYWRvYmUvY3Etc3BhLWNvbXBvbmVudC1tYXBwaW5nI01hcHRvIGxpYnJhcnkgYW5kIGZlYXR1cmVzIHdpdGggQW5ndWxhciBzcGVjaWZpY3Mgc3VjaCBhc1xuICpcbiAqIC0gU3RvcmluZyB0aGUgZWRpdGluZyBjb25maWd1cmF0aW9ucyBmb3IgZWFjaCByZXNvdXJjZSB0eXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRNYXBwaW5nV2l0aENvbmZpZyB7XG4gIC8qKlxuICAgKiBTdG9yZSBvZiBFZGl0Q29uZmlnIHN0cnVjdHVyZXNcbiAgICovXG4gIHByaXZhdGUgZWRpdENvbmZpZ01hcCA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3BhTWFwcGluZzpTUEFDb21wb25lbnRNYXBwaW5nKSB7fVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBjb21wb25lbnQgY2xhc3MgZm9yIHRoZSBnaXZlbiByZXNvdXJjZSB0eXBlcyBhbmQgYWxzbyBhbGxvd3MgdG8gcHJvdmlkZSBhbiBFZGl0Q29uZmlnIG9iamVjdFxuICAgKiBAcGFyYW0gcmVzb3VyY2VUeXBlcyAtIExpc3Qgb2YgcmVzb3VyY2UgdHlwZXNcbiAgICogQHBhcmFtIGNsYXp6IC0gQ29tcG9uZW50IGNsYXNzIHRvIGJlIHN0b3JlZFxuICAgKiBAcGFyYW0gW2VkaXRDb25maWddIC0gRWRpdCBjb25maWd1cmF0aW9uIHRvIGJlIHN0b3JlZCBmb3IgdGhlIGdpdmVuIHJlc291cmNlIHR5cGVzXG4gICAqL1xuICBtYXAocmVzb3VyY2VUeXBlcywgY2xhenosIGVkaXRDb25maWcgPSBudWxsKSB7XG4gICAgICBsZXQgaW5uZXJDbGFzcyA9IGNsYXp6O1xuXG4gICAgICBpZiAoZWRpdENvbmZpZykge1xuICAgICAgICAgIHRoaXMuZWRpdENvbmZpZ01hcFtyZXNvdXJjZVR5cGVzXSA9IGVkaXRDb25maWc7XG4gICAgICB9XG4gICAgICB0aGlzLnNwYU1hcHBpbmcubWFwKHJlc291cmNlVHlwZXMsIGlubmVyQ2xhc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgY2xhc3MgZm9yIHRoZSBnaXZlbiByZXNvdXJjZVR5cGVcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZSAtIFJlc291cmNlIHR5cGUgZm9yIHdoaWNoIHRoZSBjb21wb25lbnQgY2xhc3MgaGFzIGJlZW4gc3RvcmVkXG4gICAqL1xuICBnZXQocmVzb3VyY2VUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BhTWFwcGluZy5nZXQocmVzb3VyY2VUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBFZGl0Q29uZmlnIHN0cnVjdHVyZSBmb3IgdGhlIGdpdmVuIHR5cGVcbiAgICogQHBhcmFtIHJlc291cmNlVHlwZSAtIFJlc291cmNlIHR5cGUgZm9yIHdoaWNoIHRoZSBjb25maWd1cmF0aW9uIGhhcyBiZWVuIHN0b3JlZFxuICAgKi9cbiAgZ2V0RWRpdENvbmZpZyhyZXNvdXJjZVR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0Q29uZmlnTWFwW3Jlc291cmNlVHlwZV07XG4gIH1cbn1cblxubGV0IGNvbXBvbmVudE1hcHBpbmcgPSBuZXcgQ29tcG9uZW50TWFwcGluZ1dpdGhDb25maWcoU1BBQ29tcG9uZW50TWFwcGluZyk7XG5cbmZ1bmN0aW9uIE1hcFRvKHJlc291cmNlVHlwZXMpIHtcbiAgICByZXR1cm4gKGNsYXp6LCBlZGl0Q29uZmlnID0gbnVsbCkgPT4ge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50TWFwcGluZy5tYXAocmVzb3VyY2VUeXBlcywgY2xhenosIGVkaXRDb25maWcpO1xuICAgIH07XG59XG5cblxuZXhwb3J0IHsgY29tcG9uZW50TWFwcGluZyBhcyBDb21wb25lbnRNYXBwaW5nLCBNYXBUbyB9O1xuIiwiLypcbiAqIEFET0JFIENPTkZJREVOVElBTFxuICpcbiAqIENvcHlyaWdodCAyMDE4IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVElDRTogIEFsbCBpbmZvcm1hdGlvbiBjb250YWluZWQgaGVyZWluIGlzLCBhbmQgcmVtYWluc1xuICogdGhlIHByb3BlcnR5IG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHMgc3VwcGxpZXJzLFxuICogaWYgYW55LiAgVGhlIGludGVsbGVjdHVhbCBhbmQgdGVjaG5pY2FsIGNvbmNlcHRzIGNvbnRhaW5lZFxuICogaGVyZWluIGFyZSBwcm9wcmlldGFyeSB0byBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzXG4gKiBzdXBwbGllcnMgYW5kIG1heSBiZSBjb3ZlcmVkIGJ5IFUuUy4gYW5kIEZvcmVpZ24gUGF0ZW50cyxcbiAqIHBhdGVudHMgaW4gcHJvY2VzcywgYW5kIGFyZSBwcm90ZWN0ZWQgYnkgdHJhZGUgc2VjcmV0IG9yIGNvcHlyaWdodCBsYXcuXG4gKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcbiAqIGlzIHN0cmljdGx5IGZvcmJpZGRlbiB1bmxlc3MgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uIGlzIG9idGFpbmVkXG4gKiBmcm9tIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLlxuICovXG5cbmltcG9ydCB7Q29uc3RhbnRzIGFzIFBNQ29uc3RhbnRzfSBmcm9tICdAYWRvYmUvY3Etc3BhLXBhZ2UtbW9kZWwtbWFuYWdlcic7XG5cbmV4cG9ydCBjb25zdCBDb25zdGFudHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBuYW1lcyBhc3NvY2lhdGVkIHdpdGggYSBuZXcgc2VjdGlvbiBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIE5FV19TRUNUSU9OX0NMQVNTX05BTUVTOiAnbmV3IHNlY3Rpb24nLFxuXG4gICAgVFlQRV9QUk9QOiBQTUNvbnN0YW50cy5UWVBFX1BST1AsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGNoaWxkIGl0ZW1zIG9mIGFuIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIElURU1TX1BST1A6IFBNQ29uc3RhbnRzLklURU1TX1BST1AsXG5cbiAgICAvKipcbiAgICAgKiBPcmRlciBpbiB3aGljaCB0aGUgaXRlbXMgc2hvdWxkIGJlIGxpc3RlZFxuICAgICAqXG4gICAgICovXG4gICAgSVRFTVNfT1JERVJfUFJPUDogUE1Db25zdGFudHMuSVRFTVNfT1JERVJfUFJPUCxcblxuICAgIC8qKlxuICAgICAqIFBhdGggb2YgdGhlIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIFBBVEhfUFJPUDogUE1Db25zdGFudHMuUEFUSF9QUk9QLFxuXG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gb2YgYW4gaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgQ0hJTERSRU5fUFJPUDogUE1Db25zdGFudHMuQ0hJTERSRU5fUFJPUCxcblxuICAgIC8qKlxuICAgICAqIFBhdGggb2YgdGhlIHJlc291cmNlIGluIHRoZSBtb2RlbFxuICAgICAqXG4gICAgICovXG4gICAgREFUQV9QQVRIX1BST1A6ICc6ZGF0YVBhdGgnLFxuXG4gICAgLyoqXG4gICAgICogSGllcmFyY2hpY2FsIHR5cGUgb2YgdGhlIGl0ZW1cbiAgICAgKi9cbiAgICBISUVSQVJDSFlfVFlQRV9QUk9QOiBQTUNvbnN0YW50cy5ISUVSQVJDSFlfVFlQRV9QUk9QXG59O1xuIiwiLypcbiAqIEFET0JFIENPTkZJREVOVElBTFxuICpcbiAqIENvcHlyaWdodCAyMDE4IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVElDRTogIEFsbCBpbmZvcm1hdGlvbiBjb250YWluZWQgaGVyZWluIGlzLCBhbmQgcmVtYWluc1xuICogdGhlIHByb3BlcnR5IG9mIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHMgc3VwcGxpZXJzLFxuICogaWYgYW55LiAgVGhlIGludGVsbGVjdHVhbCBhbmQgdGVjaG5pY2FsIGNvbmNlcHRzIGNvbnRhaW5lZFxuICogaGVyZWluIGFyZSBwcm9wcmlldGFyeSB0byBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzXG4gKiBzdXBwbGllcnMgYW5kIG1heSBiZSBjb3ZlcmVkIGJ5IFUuUy4gYW5kIEZvcmVpZ24gUGF0ZW50cyxcbiAqIHBhdGVudHMgaW4gcHJvY2VzcywgYW5kIGFyZSBwcm90ZWN0ZWQgYnkgdHJhZGUgc2VjcmV0IG9yIGNvcHlyaWdodCBsYXcuXG4gKiBEaXNzZW1pbmF0aW9uIG9mIHRoaXMgaW5mb3JtYXRpb24gb3IgcmVwcm9kdWN0aW9uIG9mIHRoaXMgbWF0ZXJpYWxcbiAqIGlzIHN0cmljdGx5IGZvcmJpZGRlbiB1bmxlc3MgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uIGlzIG9idGFpbmVkXG4gKiBmcm9tIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLlxuICovXG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCBpZGVudGlmaWVzIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIFdDTSBtb2RlIHN0YXRlXG4gKi9cbmNvbnN0IFdDTV9NT0RFX01FVEFfU0VMRUNUT1I6c3RyaW5nID0gJ21ldGFbcHJvcGVydHk9XCJjcTp3Y21tb2RlXCJdJztcblxuLyoqXG4gKiBUaGUgZWRpdG9yIGlzIGluIG9uZSBvZiB0aGUgZWRpdGlvbiBtb2Rlc1xuICovXG5jb25zdCBFRElUX01PREU6c3RyaW5nID0gJ2VkaXQnO1xuXG4vKipcbiAqIFRoZSBlZGl0b3IgaXMgaW4gcHJldmlldyBtb2RlXG4gKi9cbmNvbnN0IFBSRVZJRVdfTU9ERTpzdHJpbmcgPSAncHJldmlldyc7XG4vKipcbiAqIFJldHVybnMgaWYgd2UgYXJlIGluIHRoZSBicm93c2VyIGNvbnRleHQgb3Igbm90IGJ5IGNoZWNraW5nIGZvciB0aGVcbiAqIGV4aXN0ZW5jZSBvZiB0aGUgd2luZG93IG9iamVjdFxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IFdDTSBtb2RlXG4gKlxuICogPHA+Tm90ZSB0aGF0IHRoZSB2YWx1ZSBpc24ndCwgYXMgb2YgdGhlIGRhdGUgb2YgdGhpcyB3cml0aW5nLCB1cGRhdGVkIGJ5IHRoZSBlZGl0b3I8L3A+XG4gKi9cbmZ1bmN0aW9uIGdldFdDTU1vZGUoKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICBjb25zdCB3Y21Nb2RlTWV0YTphbnkgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoV0NNX01PREVfTUVUQV9TRUxFQ1RPUik7XG4gICAgICByZXR1cm4gd2NtTW9kZU1ldGEgJiYgd2NtTW9kZU1ldGEuY29udGVudDtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgQUVNIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBVdGlscyA9IHtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBhcHAgdXNlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgQUVNIFBhZ2UgZWRpdG9yXG4gICAgICovXG4gICAgaXNJbkVkaXRvcigpIHtcbiAgICAgICAgY29uc3Qgd2NtTW9kZSA9IGdldFdDTU1vZGUoKTtcbiAgICAgICAgcmV0dXJuIHdjbU1vZGUgJiYgKEVESVRfTU9ERSA9PT0gd2NtTW9kZSB8fCBQUkVWSUVXX01PREUgPT09IHdjbU1vZGUpO1xuICAgIH1cbn07XG4iLCIvKlxuICogQURPQkUgQ09ORklERU5USUFMXG4gKlxuICogQ29weXJpZ2h0IDIwMTggQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWRcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTk9USUNFOiAgQWxsIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBoZXJlaW4gaXMsIGFuZCByZW1haW5zXG4gKiB0aGUgcHJvcGVydHkgb2YgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0cyBzdXBwbGllcnMsXG4gKiBpZiBhbnkuICBUaGUgaW50ZWxsZWN0dWFsIGFuZCB0ZWNobmljYWwgY29uY2VwdHMgY29udGFpbmVkXG4gKiBoZXJlaW4gYXJlIHByb3ByaWV0YXJ5IHRvIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHNcbiAqIHN1cHBsaWVycyBhbmQgbWF5IGJlIGNvdmVyZWQgYnkgVS5TLiBhbmQgRm9yZWlnbiBQYXRlbnRzLFxuICogcGF0ZW50cyBpbiBwcm9jZXNzLCBhbmQgYXJlIHByb3RlY3RlZCBieSB0cmFkZSBzZWNyZXQgb3IgY29weXJpZ2h0IGxhdy5cbiAqIERpc3NlbWluYXRpb24gb2YgdGhpcyBpbmZvcm1hdGlvbiBvciByZXByb2R1Y3Rpb24gb2YgdGhpcyBtYXRlcmlhbFxuICogaXMgc3RyaWN0bHkgZm9yYmlkZGVuIHVubGVzcyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24gaXMgb2J0YWluZWRcbiAqIGZyb20gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgUmVuZGVyZXIyLCBOZ1pvbmUsIFZpZXdDb250YWluZXJSZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENvbXBvbmVudE1hcHBpbmcgfSBmcm9tICcuL2NvbXBvbmVudC1tYXBwaW5nJztcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5cblxuY29uc3QgUExBQ0VIT0xERVJfQ0xBU1NfTkFNRSA9ICdjcS1wbGFjZWhvbGRlcic7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1thZW1Db21wb25lbnRdJ1xufSlcblxuLyoqXG4gKiBUaGUgY3VycmVudCBkaXJlY3RpdmUgcHJvdmlkZXMgYWR2YW5jZWQgY2FwYWJpbGl0aWVzIGFtb25nIHdoaWNoIGFyZVxuICpcbiAqIC0gVGhlIG1hbmFnZW1lbnQgb2YgdGhlIGNvbXBvbmVudCBwbGFjZWhvbGRlciBpbiB0aGUgUGFnZSBFZGl0b3JcbiAqIC0gVGhlIGR5bmFtaWMgaW5zdGFudGlhdGlvbiBvZiBjb21wb25lbnRzIGJhc2VkIG9uIGEgY29tcG9uZW50IGRlZmluaXRpb25cbiAqIC0gVGhlIGNvbnZlcnNpb24gZnJvbSBtb2RlbCBmaWVsZHMgdG8gcHJvcGVydGllcyBhbmQgaW5qZWN0aW9uIGluIHRoZSBjb21wb25lbnQgaW5zdGFuY2VcbiAqIC0gVGhlIG1hbmFnZW1lbnQgb2YgSFRNTEVsZW1lbnQgYXR0cmlidXRlcyBhbmQgY2xhc3MgbmFtZXMgb24gdGhlIG5hdGl2ZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBBRU1Db21wb25lbnREaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgLyoqXG4gICAqIER5bmFtaWNhbGx5IGNyZWF0ZWQgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIF9jb21wb25lbnQ6Q29tcG9uZW50UmVmPGFueT47XG4gIC8qKlxuICAgKiBNb2RlbCBpdGVtIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIF9jcUl0ZW06b2JqZWN0O1xuXG4gIGdldCBjcUl0ZW0oKTogb2JqZWN0IHtcbiAgICByZXR1cm4gdGhpcy5fY3FJdGVtO1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IGNxSXRlbSh2YWx1ZTogb2JqZWN0KSB7XG4gICAgdGhpcy5fY3FJdGVtID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnREYXRhKCk7XG4gIH1cblxuICAvKipcbiAgICogUGF0aCB0byB0aGUgbW9kZWwgc3RydWN0dXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGNxUGF0aDpzdHJpbmc7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGl0ZW1OYW1lOnN0cmluZztcbiAgLyoqXG4gICAqIEh0bWxFbGVtZW50IGF0dHJpYnV0ZXMgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGl0ZW1BdHRyczogb2JqZWN0O1xuXG4gIEBJbnB1dCgpIGFlbUNvbXBvbmVudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgZmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5yZW5kZXJDb21wb25lbnQoQ29tcG9uZW50TWFwcGluZy5nZXQodGhpcy50eXBlKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgY3FJdGVtIGlmIGV4aXN0cy5cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNxSXRlbSAmJiB0aGlzLmNxSXRlbVtDb25zdGFudHMuVFlQRV9QUk9QXTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBhIGNvbXBvbmVudCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb25cbiAgICpcbiAgICogQHBhcmFtIGNvbXBvbmVudERlZmluaXRpb24gVGhlIGNvbXBvbmVudCBkZWZpbml0aW9uIHRvIHJlbmRlclxuICAgKi9cbiAgcHJpdmF0ZSByZW5kZXJDb21wb25lbnQoY29tcG9uZW50RGVmaW5pdGlvbjphbnkpIHtcbiAgICBpZiAoY29tcG9uZW50RGVmaW5pdGlvbikge1xuICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudERlZmluaXRpb24pO1xuICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB0aGlzLl9jb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnREYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRhdGEgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB0aGUgZGF0YSBvZiB0aGUgZGlyZWN0aXZlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUNvbXBvbmVudERhdGEoKSB7XG4gICAgaWYgKCF0aGlzLl9jb21wb25lbnQgfHwgIXRoaXMuX2NvbXBvbmVudC5pbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5jcUl0ZW0pO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHByb3BLZXkgPSBrZXk7XG5cbiAgICAgICAgaWYgKHByb3BLZXkuc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybWF0aW9uIG9mIGludGVybmFsIHByb3BlcnRpZXMgbmFtZXNwYWNlZCB3aXRoIFs6XSB0byBbY3FdXG4gICAgICAgICAgICAvLyA6bXlQcm9wZXJ0eSA9PiBjcU15UHJvcGVydHlcbiAgICAgICAgICAgIGxldCB0ZW1wS2V5ID0gcHJvcEtleS5zdWJzdHIoMSk7XG4gICAgICAgICAgICBwcm9wS2V5ID0gXCJjcVwiICsgdGVtcEtleS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHRlbXBLZXkuc3Vic3RyKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29tcG9uZW50Lmluc3RhbmNlW3Byb3BLZXldID0gdGhpcy5jcUl0ZW1ba2V5XTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NvbXBvbmVudC5pbnN0YW5jZS5jcVBhdGggPSB0aGlzLmNxUGF0aDtcbiAgICB0aGlzLl9jb21wb25lbnQuaW5zdGFuY2UuaXRlbU5hbWUgPSB0aGlzLml0ZW1OYW1lO1xuICAgIGxldCBlZGl0Q29uZmlnID0gQ29tcG9uZW50TWFwcGluZy5nZXRFZGl0Q29uZmlnKHRoaXMudHlwZSk7XG4gICAgaWYgKGVkaXRDb25maWcgJiYgVXRpbHMuaXNJbkVkaXRvcikge1xuICAgICAgdGhpcy5zZXR1cFBsYWNlaG9sZGVyKGVkaXRDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgaXRlbSBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIHNldHVwSXRlbUF0dHJzKCkge1xuICAgIGlmICh0aGlzLml0ZW1BdHRycykge1xuICAgICAgbGV0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLml0ZW1BdHRycyk7XG5cbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgIGxldCBjbGFzc2VzID0gdGhpcy5pdGVtQXR0cnNba2V5XS5zcGxpdCgnICcpO1xuICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaCgoaXRlbUNsYXNzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBpdGVtQ2xhc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBrZXkgLCB0aGlzLml0ZW1BdHRyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBlIGRpc3BsYXllZC5cbiAgICpcbiAgICogQHBhcmFtIGVkaXRDb25maWcgLSB0aGUgZWRpdCBjb25maWcgb2YgdGhlIGRpcmVjdGl2ZVxuICAgKi9cbiAgcHJpdmF0ZSB1c2VQbGFjZWhvbGRlcihlZGl0Q29uZmlnKSB7XG4gICAgcmV0dXJuIGVkaXRDb25maWcuaXNFbXB0eSAmJiB0eXBlb2YgZWRpdENvbmZpZy5pc0VtcHR5ID09PSBcImZ1bmN0aW9uXCIgJiYgZWRpdENvbmZpZy5pc0VtcHR5KHRoaXMuY3FJdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cHMgdGhlIHBsYWNlaG9sZGVyIG9mIG5lZWRlZCBmb3IgdGhlIEFFTSBlZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIGVkaXRDb25maWcgLSB0aGUgZWRpdENvbmZpZywgd2hpY2ggd2lsbCBkaWN0YXRlIHRoZSBjbGFzc2VzIHRvIGJlIGFkZGVkIG9uLlxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cFBsYWNlaG9sZGVyKGVkaXRDb25maWcpIHtcbiAgICBpZiAodGhpcy51c2VQbGFjZWhvbGRlcihlZGl0Q29uZmlnKSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBQTEFDRUhPTERFUl9DTEFTU19OQU1FKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIFwiZGF0YS1lbXB0eXRleHRcIiwgZWRpdENvbmZpZy5lbXB0eUxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBQTEFDRUhPTERFUl9DTEFTU19OQU1FKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5fY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIFwiZGF0YS1lbXB0eXRleHRcIik7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuc2V0dXBJdGVtQXR0cnMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2NvbXBvbmVudCAmJiB0aGlzLl9jb21wb25lbnQuZGVzdHJveSgpO1xuICB9XG5cbn1cbiIsIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gXCIuLi91dGlsc1wiO1xuXG5jb25zdCBQTEFDRUhPTERFUl9DTEFTU19OQU1FUyA9IENvbnN0YW50cy5ORVdfU0VDVElPTl9DTEFTU19OQU1FUztcbmNvbnN0IFBMQUNFSE9MREVSX0lURU1fTkFNRSA9ICcqJztcbmNvbnN0IENPTlRBSU5FUl9DTEFTU19OQU1FUyA9ICdhZW0tY29udGFpbmVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYWVtLWNvbnRhaW5lcicsXG4gIGhvc3Q6IHtcbiAgICAgICdbY2xhc3NdJzogJ2hvc3RDbGFzc2VzJyxcbiAgICAgICdbYXR0ci5kYXRhLWNxLWRhdGEtcGF0aF0nOidjcVBhdGgnXG4gIH0sXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbUtleSBvZiBjcUl0ZW1zT3JkZXJcIj5cbiAgPG5nLWNvbnRhaW5lciBbYWVtQ29tcG9uZW50XSBbY3FJdGVtXT0nZ2V0SXRlbShpdGVtS2V5KScgW2NxUGF0aF09J2dldERhdGFQYXRoKGl0ZW1LZXkpJyBbaXRlbU5hbWVdPSdpdGVtS2V5Jz48L25nLWNvbnRhaW5lcj5cbiAgPGRpdiAqbmdJZj1cImlzSW5FZGl0TW9kZVwiIFthdHRyLmRhdGEtY3EtZGF0YS1wYXRoXT1cInBsYWNlaG9sZGVyUGF0aFwiIFtjbGFzc109XCJnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKVwiPjwvZGl2PlxuPC9uZy1jb250YWluZXI+XG5gXG59KVxuLyoqXG4gKiBUaGUgY3VycmVudCBjb21wb25lbnQgcHJvdmlkZXMgdGhlIGJhc2UgcHJlc2VudGF0aW9uYWwgbG9naWMgY29tbW9uIHRvIGNvbnRhaW5lcnMgc3VjaCBhcyBhIGdyaWQgb3IgYSBwYWdlLlxuICogQ29udGFpbmVyIGhhdmUgaW4gY29tbW9uIHRoZSBub3Rpb24gb2YgaXRlbSBob2xkZXJzLiBJdGVtcyBhcmUgcmVwcmVzZW50ZWQgaW4gdGhlIG1vZGVsIGJ5IHRoZSBmaWVsZHMgXzppdGVtc18gYW5kIF86aXRlbXNPcmRlcl9cbiAqL1xuZXhwb3J0IGNsYXNzIEFFTUNvbnRhaW5lckNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBNYXAgb2YgbW9kZWwgaXRlbXMgaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgY29udGFpbmVyXG4gICAqL1xuICBASW5wdXQoKSBjcUl0ZW1zO1xuICAvKipcbiAgICogQXJyYXkgb2YgbW9kZWwgaXRlbSBrZXlzXG4gICAqL1xuICBASW5wdXQoKSBjcUl0ZW1zT3JkZXI7XG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY3FQYXRoOnN0cmluZyA9ICcnO1xuICAvKipcbiAgICogS2V5IG9mIHRoZSBtb2RlbCBzdHJ1Y3R1cmVcbiAgICovXG4gIEBJbnB1dCgpIG1vZGVsTmFtZTpzdHJpbmcgPSAnJztcbiAgLyoqXG4gICAqIENsYXNzIG5hbWVzIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY2xhc3NOYW1lczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdlYXRoZXIgb2Ygbm90IHdlIGFyZSBpbiB0aGUgZWRpdG9yXG4gICAqL1xuICBnZXQgaXNJbkVkaXRNb2RlKCkge1xuICAgIHJldHVybiBVdGlscy5pc0luRWRpdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWdncmVnYXRlZCBwYXRoIG9mIHRoaXMgY29udGFpbmVyIHBhdGggYW5kIHRoZSBwcm92aWRlZCBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIC0gdGhlIHByb3ZpZGVkIHBhdGggdG8gYWdncmVnYXRlIHdpdGggdGhlIGNvbnRhaW5lciBwYXRoXG4gICAqL1xuICBnZXREYXRhUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3FQYXRoID8gdGhpcy5jcVBhdGggKyAnLycgKyBwYXRoIDogcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVtIGRhdGEgZnJvbSB0aGUgY3FNb2RlbFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbUtleSAtIHRoZSBpdGVtS2V5IHRvIGxvb2sgZm9yIGluIHRoZSBpdGVtcy5cbiAgICovXG4gIGdldEl0ZW0oaXRlbUtleSkge1xuICAgIHJldHVybiB0aGlzLmNxSXRlbXMgJiYgdGhpcy5jcUl0ZW1zW2l0ZW1LZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWVzIG9mIHRoZSBjb250YWluZXIgYmFzZWQgb24gdGhlIGRhdGEgZnJvbSB0aGUgY3FNb2RlbFxuICAgKi9cbiAgZ2V0SG9zdENsYXNzTmFtZXMoKSB7XG4gICAgcmV0dXJuIENPTlRBSU5FUl9DTEFTU19OQU1FUztcbiAgfVxuXG4gIGdldCBob3N0Q2xhc3NlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SG9zdENsYXNzTmFtZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjbGFzc2VzXG4gICAqL1xuICBnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKSB7XG4gICAgcmV0dXJuIFBMQUNFSE9MREVSX0NMQVNTX05BTUVTO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHBhdGhcbiAgICovXG4gIGdldCBwbGFjZWhvbGRlclBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3FQYXRoICYmIHRoaXMuY3FQYXRoICsgJy8nICsgUExBQ0VIT0xERVJfSVRFTV9OQU1FO1xuICB9XG59XG5cbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCIvKlxuICogQURPQkUgQ09ORklERU5USUFMXG4gKlxuICogQ29weXJpZ2h0IDIwMTggQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWRcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTk9USUNFOiAgQWxsIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBoZXJlaW4gaXMsIGFuZCByZW1haW5zXG4gKiB0aGUgcHJvcGVydHkgb2YgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0cyBzdXBwbGllcnMsXG4gKiBpZiBhbnkuICBUaGUgaW50ZWxsZWN0dWFsIGFuZCB0ZWNobmljYWwgY29uY2VwdHMgY29udGFpbmVkXG4gKiBoZXJlaW4gYXJlIHByb3ByaWV0YXJ5IHRvIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHNcbiAqIHN1cHBsaWVycyBhbmQgbWF5IGJlIGNvdmVyZWQgYnkgVS5TLiBhbmQgRm9yZWlnbiBQYXRlbnRzLFxuICogcGF0ZW50cyBpbiBwcm9jZXNzLCBhbmQgYXJlIHByb3RlY3RlZCBieSB0cmFkZSBzZWNyZXQgb3IgY29weXJpZ2h0IGxhdy5cbiAqIERpc3NlbWluYXRpb24gb2YgdGhpcyBpbmZvcm1hdGlvbiBvciByZXByb2R1Y3Rpb24gb2YgdGhpcyBtYXRlcmlhbFxuICogaXMgc3RyaWN0bHkgZm9yYmlkZGVuIHVubGVzcyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24gaXMgb2J0YWluZWRcbiAqIGZyb20gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQUVNQ29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi4vYWVtLWNvbnRhaW5lci9hZW0tY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCBQTEFDRUhPTERFUl9DTEFTU19OQU1FUyA9ICcgYWVtLUdyaWQtbmV3Q29tcG9uZW50JztcbmNvbnN0IFJFU1BPTlNJVkVfR1JJRF9UWVBFID0gJ3djbS9mb3VuZGF0aW9uL2NvbXBvbmVudHMvcmVzcG9uc2l2ZWdyaWQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdhZW0tcmVzcG9uc2l2ZWdyaWQnLFxuICBob3N0OiB7XG4gICAgICAnW2NsYXNzXSc6ICdob3N0Q2xhc3NlcycsXG4gICAgICAnW2F0dHIuZGF0YS1jcS1kYXRhLXBhdGhdJzonY3FQYXRoJ1xuICB9LFxuICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW1LZXkgb2YgY3FJdGVtc09yZGVyXCI+XG4gIDxkaXYgW2FlbU1vZGVsUHJvdmlkZXJdIFtjcUl0ZW1dPSdnZXRJdGVtKGl0ZW1LZXkpJyBbY3FQYXRoXT0nZ2V0RGF0YVBhdGgoaXRlbUtleSknIFtpdGVtTmFtZV09J2l0ZW1LZXknIFtjbGFzc109XCJnZXRDb2x1bW5DbGFzc05hbWVzKGl0ZW1LZXkpXCIgW2F0dHIuZGF0YS1jcS1kYXRhLXBhdGhdPSdnZXRBdHRyRGF0YVBhdGgoaXRlbUtleSknPlxuICA8L2Rpdj5cbjwvbmctY29udGFpbmVyPlxuPGRpdiAqbmdJZj1cImlzSW5FZGl0TW9kZVwiIFthdHRyLmRhdGEtY3EtZGF0YS1wYXRoXT1cInBsYWNlaG9sZGVyUGF0aFwiIFtjbGFzc109XCJnZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKVwiPjwvZGl2PlxuXG5cbmAsXG59KVxuLyoqXG4gKiBUaGUgY3VycmVudCBjbGFzcyBjYXJyaWVzIHRoZSBiYXNlIHByZXNlbnRhdGlvbmFsIGxvZ2ljIG9mIHRoZSBBRU0gTGF5b3V0IENvbnRhaW5lciAoYWthLiBSZXNwb25zaXZlIGdyaWQpXG4gKi9cbmV4cG9ydCBjbGFzcyBBRU1SZXNwb25zaXZlR3JpZENvbXBvbmVudCBleHRlbmRzIEFFTUNvbnRhaW5lckNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDbGFzcyBuYW1lcyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcmVzcG9uc2l2ZSBncmlkXG4gICAqL1xuICBASW5wdXQoKSBncmlkQ2xhc3NOYW1lczogc3RyaW5nO1xuICAvKipcbiAgICogTWFwIG9mIGNsYXNzIG5hbWVzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBjaGlsZCBvZiB0aGUgY3VycmVudCByZXNwb25zaXZlIGdyaWRcbiAgICovXG4gIEBJbnB1dCgpIGNvbHVtbkNsYXNzTmFtZXM6IE9iamVjdDtcbiAgLyoqXG4gICAqIENsYXNzIG5hbWVzIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY2xhc3NOYW1lczogc3RyaW5nO1xuICAvKipcbiAgICogQ3VycmVudCBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgZ3JpZFxuICAgKi9cbiAgQElucHV0KCkgY29sdW1uQ291bnQ6IG51bWJlcjtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29sdW1uIGNsYXNzIG5hbWVzIGZvciBhIGdpdmVuIGNvbHVtblxuICAgKiBAcGFyYW0gaXRlbUtleSAtIFRoZSBrZXkgb2YgdGhlIGNvbHVtbiBpdGVtXG4gICAqL1xuICBnZXRDb2x1bW5DbGFzc05hbWVzKGl0ZW1LZXk6c3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sdW1uQ2xhc3NOYW1lcyAmJiB0aGlzLmNvbHVtbkNsYXNzTmFtZXNbaXRlbUtleV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY2xhc3Nlc1xuICAgKi9cbiAgZ2V0UGxhY2Vob2xkZXJDbGFzc05hbWVzKCkge1xuICAgIHJldHVybiBzdXBlci5nZXRQbGFjZWhvbGRlckNsYXNzTmFtZXMoKSArIFBMQUNFSE9MREVSX0NMQVNTX05BTUVTO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWVzIG9mIHRoZSByZXNwb25zaXZlIGdyaWQgYmFzZWQgb24gdGhlIGRhdGEgZnJvbSB0aGUgY3FNb2RlbFxuICAgKi9cbiAgZ2V0SG9zdENsYXNzTmFtZXMoKSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBzdXBlci5nZXRIb3N0Q2xhc3NOYW1lcygpO1xuXG4gICAgaWYgKHRoaXMuY2xhc3NOYW1lcykge1xuICAgICAgICBjbGFzc05hbWVzICs9ICcgJyArICh0aGlzLmNsYXNzTmFtZXMgfHwgJycpIDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lcyArICcgJyArIHRoaXMuZ3JpZENsYXNzTmFtZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWdncmVnYXRlZCBwYXRoIG9mIHRoaXMgY29udGFpbmVyIHBhdGggYW5kIHRoZSBwcm92aWRlZCBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIC0gdGhlIHByb3ZpZGVkIHBhdGggdG8gYWdncmVnYXRlIHdpdGggdGhlIGNvbnRhaW5lciBwYXRoXG4gICAqL1xuICBnZXRBdHRyRGF0YVBhdGgocGF0aCkge1xuICAgIGxldCBpdGVtID0gdGhpcy5nZXRJdGVtKHBhdGgpO1xuICAgIGlmIChpdGVtICYmIGl0ZW1bQ29uc3RhbnRzLlRZUEVfUFJPUF0gPT09IFJFU1BPTlNJVkVfR1JJRF9UWVBFKSB7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGFkZCB0aGUgcGF0aCBmb3IgdGhlIHdyYXBwZXIgZm9yIGEgcmVwb25zaXZlZ3JpZFxuICAgICAgLy8gVGhlIHJlcG9uc2l2ZWdyaWQgYWRkcyB0aGUgcGF0aCBvbiBpdCdzIG93blxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0YVBhdGgocGF0aCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBBRE9CRSBDT05GSURFTlRJQUxcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZFxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RJQ0U6ICBBbGwgaW5mb3JtYXRpb24gY29udGFpbmVkIGhlcmVpbiBpcywgYW5kIHJlbWFpbnNcbiAqIHRoZSBwcm9wZXJ0eSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBhbmQgaXRzIHN1cHBsaWVycyxcbiAqIGlmIGFueS4gIFRoZSBpbnRlbGxlY3R1YWwgYW5kIHRlY2huaWNhbCBjb25jZXB0cyBjb250YWluZWRcbiAqIGhlcmVpbiBhcmUgcHJvcHJpZXRhcnkgdG8gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0c1xuICogc3VwcGxpZXJzIGFuZCBtYXkgYmUgY292ZXJlZCBieSBVLlMuIGFuZCBGb3JlaWduIFBhdGVudHMsXG4gKiBwYXRlbnRzIGluIHByb2Nlc3MsIGFuZCBhcmUgcHJvdGVjdGVkIGJ5IHRyYWRlIHNlY3JldCBvciBjb3B5cmlnaHQgbGF3LlxuICogRGlzc2VtaW5hdGlvbiBvZiB0aGlzIGluZm9ybWF0aW9uIG9yIHJlcHJvZHVjdGlvbiBvZiB0aGlzIG1hdGVyaWFsXG4gKiBpcyBzdHJpY3RseSBmb3JiaWRkZW4gdW5sZXNzIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbiBpcyBvYnRhaW5lZFxuICogZnJvbSBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1vZGVsTWFuYWdlciB9IGZyb20gXCJAYWRvYmUvY3Etc3BhLXBhZ2UtbW9kZWwtbWFuYWdlclwiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdbYWVtTW9kZWxQcm92aWRlcl0nLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgW2FlbUNvbXBvbmVudF0gW2NxSXRlbV09J2NxSXRlbScgW2NxUGF0aF09J2NxUGF0aCcgW2l0ZW1OYW1lXT0naXRlbU5hbWUnPjwvbmctY29udGFpbmVyPmBcbn0pXG4vKipcbiAqIFRoZSBjdXJyZW50IGNvbXBvbmVudCBpcyByZXNwb25zaWJsZSBmb3IgcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgTW9kZWxNYW5hZ2VyIGFuZCB0aGUgbW9kZWwgb2YgYSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEFFTU1vZGVsUHJvdmlkZXJDb21wb25lbnQge1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGNxUGF0aDtcbiAgLyoqXG4gICAqIE1vZGVsIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IG1vZGVsIHByb3ZpZGVyIGNvbXBvbmVudFxuICAgKi9cbiAgQElucHV0KCkgY3FJdGVtO1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgaXRlbSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbW9kZWwgcHJvdmlkZXIgY29tcG9uZW50XG4gICAqL1xuICBASW5wdXQoKSBpdGVtTmFtZTtcblxuICBASW5wdXQoKSBhZW1Nb2RlbFByb3ZpZGVyO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBpdGVtIGRhdGFcbiAgICovXG4gIHVwZGF0ZUl0ZW0oKSB7XG4gICAgTW9kZWxNYW5hZ2VyLmdldERhdGEoe3BhdGg6IHRoaXMuY3FQYXRofSkudGhlbihtb2RlbCA9PiB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jcUl0ZW0gPSBtb2RlbDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBNb2RlbE1hbmFnZXIuYWRkTGlzdGVuZXIodGhpcy5jcVBhdGgsIHRoaXMudXBkYXRlSXRlbS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIG5nRGVzdHJveSgpIHtcbiAgICBNb2RlbE1hbmFnZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5jcVBhdGgsIHRoaXMudXBkYXRlSXRlbS5iaW5kKHRoaXMpKTtcbiAgfVxufVxuXG4iLCIvKlxuICogQURPQkUgQ09ORklERU5USUFMXG4gKlxuICogQ29weXJpZ2h0IDIwMTggQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWRcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTk9USUNFOiAgQWxsIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBoZXJlaW4gaXMsIGFuZCByZW1haW5zXG4gKiB0aGUgcHJvcGVydHkgb2YgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgYW5kIGl0cyBzdXBwbGllcnMsXG4gKiBpZiBhbnkuICBUaGUgaW50ZWxsZWN0dWFsIGFuZCB0ZWNobmljYWwgY29uY2VwdHMgY29udGFpbmVkXG4gKiBoZXJlaW4gYXJlIHByb3ByaWV0YXJ5IHRvIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIGFuZCBpdHNcbiAqIHN1cHBsaWVycyBhbmQgbWF5IGJlIGNvdmVyZWQgYnkgVS5TLiBhbmQgRm9yZWlnbiBQYXRlbnRzLFxuICogcGF0ZW50cyBpbiBwcm9jZXNzLCBhbmQgYXJlIHByb3RlY3RlZCBieSB0cmFkZSBzZWNyZXQgb3IgY29weXJpZ2h0IGxhdy5cbiAqIERpc3NlbWluYXRpb24gb2YgdGhpcyBpbmZvcm1hdGlvbiBvciByZXByb2R1Y3Rpb24gb2YgdGhpcyBtYXRlcmlhbFxuICogaXMgc3RyaWN0bHkgZm9yYmlkZGVuIHVubGVzcyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24gaXMgb2J0YWluZWRcbiAqIGZyb20gQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBRU1Db250YWluZXJDb21wb25lbnQgfSBmcm9tICcuLi9hZW0tY29udGFpbmVyL2FlbS1jb250YWluZXIuY29tcG9uZW50JztcblxuY29uc3QgUEFHRV9NT0RFTF9TRVBBUkFUT1IgPSAnL2pjcjpjb250ZW50Lyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2FlbS1wYWdlJyxcbiAgaG9zdDoge1xuICAgICAgJ1tjbGFzc10nOiAnaG9zdENsYXNzZXMnLFxuICAgICAgJ1thdHRyLmRhdGEtY3EtZGF0YS1wYXRoXSc6J2NxUGF0aCdcbiAgfSxcbiAgdGVtcGxhdGU6IGA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBpdGVtS2V5IG9mIGNxSXRlbXNPcmRlclwiPlxuICA8bmctY29udGFpbmVyIFthZW1Db21wb25lbnRdIFtjcUl0ZW1dPSdnZXRJdGVtKGl0ZW1LZXkpJyBbY3FQYXRoXT0nZ2V0RGF0YVBhdGgoaXRlbUtleSknIFtpdGVtTmFtZV09J2l0ZW1LZXknPjwvbmctY29udGFpbmVyPlxuICA8ZGl2ICpuZ0lmPVwiaXNJbkVkaXRNb2RlXCIgW2F0dHIuZGF0YS1jcS1kYXRhLXBhdGhdPVwicGxhY2Vob2xkZXJQYXRoXCIgW2NsYXNzXT1cImdldFBsYWNlaG9sZGVyQ2xhc3NOYW1lcygpXCI+PC9kaXY+XG48L25nLWNvbnRhaW5lcj5cbmBcbn0pXG4vKipcbiAqIFRoZSBjdXJyZW50IGNvbXBvbmVudCBjYXJyaWVzIHRoZSBiYXNlIHByZXNlbnRhdGlvbmFsIGxvZ2ljIG9mIHBhZ2UgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBBRU1QYWdlQ29tcG9uZW50IGV4dGVuZHMgQUVNQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFnZ3JlZ2F0ZWQgcGF0aCBvZiB0aGlzIGNvbnRhaW5lciBwYXRoIGFuZCB0aGUgcHJvdmlkZWQgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwcm92aWRlZCBwYXRoIHRvIGFnZ3JlZ2F0ZSB3aXRoIHRoZSBjb250YWluZXIgcGF0aFxuICAgKi9cbiAgZ2V0RGF0YVBhdGgocGF0aCkge1xuICAgIHJldHVybiB0aGlzLmNxUGF0aCA/IHRoaXMuY3FQYXRoICsgUEFHRV9NT0RFTF9TRVBBUkFUT1IgKyBwYXRoIDogcGF0aDtcbiAgfVxuXG59XG5cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IDIwMTggQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiAgb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqICB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqICBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqICBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQUVNQ29tcG9uZW50RGlyZWN0aXZlIH0gZnJvbSBcIi4vbGF5b3V0L2FlbS1jb21wb25lbnQuZGlyZWN0aXZlXCI7XG5pbXBvcnQgeyBBRU1Nb2RlbFByb3ZpZGVyQ29tcG9uZW50IH0gZnJvbSBcIi4vbGF5b3V0L2FlbS1tb2RlbC1wcm92aWRlci9hZW0tbW9kZWwtcHJvdmlkZXIuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBRU1Db250YWluZXJDb21wb25lbnQgfSBmcm9tIFwiLi9sYXlvdXQvYWVtLWNvbnRhaW5lci9hZW0tY29udGFpbmVyLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQUVNUGFnZUNvbXBvbmVudCB9IGZyb20gXCIuL2xheW91dC9hZW0tcGFnZS9hZW0tcGFnZS5jb21wb25lbnRcIjtcbmltcG9ydCB7IEFFTVJlc3BvbnNpdmVHcmlkQ29tcG9uZW50IH0gZnJvbSBcIi4vbGF5b3V0L2FlbS1yZXNwb25zaXZlZ3JpZC9hZW0tcmVzcG9uc2l2ZWdyaWQuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcblxuICBkZWNsYXJhdGlvbnM6IFtBRU1Db250YWluZXJDb21wb25lbnQsIEFFTVJlc3BvbnNpdmVHcmlkQ29tcG9uZW50LCBBRU1Db21wb25lbnREaXJlY3RpdmUsIEFFTU1vZGVsUHJvdmlkZXJDb21wb25lbnQsIEFFTVBhZ2VDb21wb25lbnRdLFxuICBleHBvcnRzOiBbQUVNQ29udGFpbmVyQ29tcG9uZW50LCBBRU1SZXNwb25zaXZlR3JpZENvbXBvbmVudCwgQUVNQ29tcG9uZW50RGlyZWN0aXZlLCBBRU1Nb2RlbFByb3ZpZGVyQ29tcG9uZW50LCBBRU1QYWdlQ29tcG9uZW50XSxcbiAgZW50cnlDb21wb25lbnRzOiBbQUVNQ29udGFpbmVyQ29tcG9uZW50LCBBRU1SZXNwb25zaXZlR3JpZENvbXBvbmVudCwgQUVNUGFnZUNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU3BhQW5ndWxhckVkaXRhYmxlQ29tcG9uZW50c01vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJlc29sdmUsIEFjdGl2YXRlZFJvdXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQWVtUGFnZURhdGFSZXNvbHZlciBpbXBsZW1lbnRzIFJlc29sdmUgPCBzdHJpbmcgPiB7XG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWJzb2x1dGUgcmVzb3VyY2UgcGF0aCB3aXRob3V0IGV4dGVuc2lvbi5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gcmV0dXJuczogJy9jb250ZW50L2FhL2JiJyBmb3Igcm91dGUudXJsIFsgJ2NvbnRlbnQnLCAnYWEnLCAnYmIuaHRtbCcgXVxuICAgKiByZXNvbHZlKHJvdXRlKVxuICAgKiBAcGFyYW0gcm91dGUgLSByb3V0ZVxuICAgKiBAcmV0dXJucyBhYnNvbHV0ZSByZXNvdXJjZSBwYXRoIHdpdGhvdXQgZXh0ZW5zaW9uXG4gICAqL1xuICByZXNvbHZlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KSB7XG4gICAgcmV0dXJuICcvJyArIHJvdXRlLnVybC5qb2luKCcvJykucmVwbGFjZSgvXFwuW14vLl0rJC8sICcnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgUm91dGVSZXVzZVN0cmF0ZWd5LCBEZXRhY2hlZFJvdXRlSGFuZGxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIFJvdXRlUmV1c2VTdHJhdGVneSB0byBjdXN0b21pemUgcm91dGUgcmV1c2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBBZW1QYWdlUm91dGVSZXVzZVN0cmF0ZWd5IGltcGxlbWVudHMgUm91dGVSZXVzZVN0cmF0ZWd5IHtcbiAgLyoqIERldGVybWluZXMgaWYgdGhpcyByb3V0ZSAoYW5kIGl0cyBzdWJ0cmVlKSBzaG91bGQgYmUgZGV0YWNoZWQgdG8gYmUgcmV1c2VkIGxhdGVyLiAqL1xuICBzaG91bGREZXRhY2gocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogTm90IHN0b3JpbmcgZGV0ZWFjaGVkIHJvdXRlLiAqL1xuICBzdG9yZShyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgZGV0YWNoZWRUcmVlOiBEZXRhY2hlZFJvdXRlSGFuZGxlKTogdm9pZCB7fVxuXG4gIC8qKiBEZXRlcm1pbmVzIGlmIHRoaXMgcm91dGUgKGFuZCBpdHMgc3VidHJlZSkgc2hvdWxkIGJlIHJlYXR0YWNoZWQuICovXG4gIHNob3VsZEF0dGFjaChyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBSZXRyaWV2ZXMgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHJvdXRlLiAqL1xuICByZXRyaWV2ZShyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IERldGFjaGVkUm91dGVIYW5kbGUgfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBEZXRlcm1pbmVzIGlmIGEgcm91dGUgc2hvdWxkIGJlIHJldXNlZCAqL1xuICBzaG91bGRSZXVzZVJvdXRlKGZ1dHVyZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgY3VycjogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlNQQUNvbXBvbmVudE1hcHBpbmciLCJQTUNvbnN0YW50cyIsIkNvbXBvbmVudE1hcHBpbmciLCJEaXJlY3RpdmUiLCJSZW5kZXJlcjIiLCJWaWV3Q29udGFpbmVyUmVmIiwiQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIiwiTmdab25lIiwiSW5wdXQiLCJDb21wb25lbnQiLCJQTEFDRUhPTERFUl9DTEFTU19OQU1FUyIsInRzbGliXzEuX19leHRlbmRzIiwiTW9kZWxNYW5hZ2VyIiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiLCJJbmplY3RhYmxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7UUFBQTtRQU1FLG9DQUFvQixVQUE4QjtZQUE5QixlQUFVLEdBQVYsVUFBVSxDQUFvQjs7OztpQ0FGMUIsRUFBRTtTQUU0Qjs7Ozs7Ozs7Ozs7Ozs7UUFRdEQsd0NBQUc7Ozs7Ozs7WUFBSCxVQUFJLGFBQWEsRUFBRSxLQUFLLEVBQUUsVUFBaUI7Z0JBQWpCLDJCQUFBO29CQUFBLGlCQUFpQjs7Z0JBQ3ZDLHFCQUFJLFVBQVUsR0FBRyxLQUFLLENBQUM7Z0JBRXZCLElBQUksVUFBVSxFQUFFO29CQUNaLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEdBQUcsVUFBVSxDQUFDO2lCQUNsRDtnQkFDRCxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBVSxDQUFDLENBQUM7YUFDbEQ7Ozs7Ozs7Ozs7UUFNRCx3Q0FBRzs7Ozs7WUFBSCxVQUFJLFlBQVk7Z0JBQ2QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUMxQzs7Ozs7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